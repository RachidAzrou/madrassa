var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";

// server/storage/databaseStorage.ts
import { eq, and } from "drizzle-orm";

// server/db.ts
import { Pool, neonConfig } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-serverless";
import ws from "ws";

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  assessments: () => assessments,
  attendance: () => attendance,
  attendanceRelations: () => attendanceRelations,
  behaviorAssessments: () => behaviorAssessments,
  courses: () => courses,
  enrollments: () => enrollments,
  events: () => events,
  examinations: () => examinations,
  feeDiscounts: () => feeDiscounts,
  feeSettings: () => feeSettings,
  fees: () => fees,
  grades: () => grades,
  guardians: () => guardians,
  guardiansRelations: () => guardiansRelations,
  insertAssessmentSchema: () => insertAssessmentSchema,
  insertAttendanceSchema: () => insertAttendanceSchema,
  insertBehaviorAssessmentSchema: () => insertBehaviorAssessmentSchema,
  insertCourseSchema: () => insertCourseSchema,
  insertEnrollmentSchema: () => insertEnrollmentSchema,
  insertEventSchema: () => insertEventSchema,
  insertExaminationSchema: () => insertExaminationSchema,
  insertFeeDiscountSchema: () => insertFeeDiscountSchema,
  insertFeeSchema: () => insertFeeSchema,
  insertFeeSettingsSchema: () => insertFeeSettingsSchema,
  insertGradeSchema: () => insertGradeSchema,
  insertGuardianSchema: () => insertGuardianSchema,
  insertLessonSchema: () => insertLessonSchema,
  insertProgramSchema: () => insertProgramSchema,
  insertStudentGroupEnrollmentSchema: () => insertStudentGroupEnrollmentSchema,
  insertStudentGroupSchema: () => insertStudentGroupSchema,
  insertStudentGuardianSchema: () => insertStudentGuardianSchema,
  insertStudentProgramSchema: () => insertStudentProgramSchema,
  insertStudentSchema: () => insertStudentSchema,
  insertTeacherAttendanceSchema: () => insertTeacherAttendanceSchema,
  insertTeacherAvailabilitySchema: () => insertTeacherAvailabilitySchema,
  insertTeacherCourseAssignmentSchema: () => insertTeacherCourseAssignmentSchema,
  insertTeacherLanguageSchema: () => insertTeacherLanguageSchema,
  insertTeacherSchema: () => insertTeacherSchema,
  insertUserSchema: () => insertUserSchema,
  lessons: () => lessons,
  programs: () => programs,
  programsRelations: () => programsRelations,
  studentGroupEnrollments: () => studentGroupEnrollments,
  studentGroups: () => studentGroups,
  studentGuardians: () => studentGuardians,
  studentGuardiansRelations: () => studentGuardiansRelations,
  studentPrograms: () => studentPrograms,
  studentProgramsRelations: () => studentProgramsRelations,
  students: () => students,
  studentsRelations: () => studentsRelations,
  teacherAttendance: () => teacherAttendance,
  teacherAttendanceRelations: () => teacherAttendanceRelations,
  teacherAvailability: () => teacherAvailability,
  teacherAvailabilityRelations: () => teacherAvailabilityRelations,
  teacherCourseAssignments: () => teacherCourseAssignments,
  teacherCourseAssignmentsRelations: () => teacherCourseAssignmentsRelations,
  teacherLanguages: () => teacherLanguages,
  teacherLanguagesRelations: () => teacherLanguagesRelations,
  teachers: () => teachers,
  teachersRelations: () => teachersRelations,
  users: () => users
});
import { pgTable, text, serial, integer, boolean, date, timestamp, unique, decimal } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
var students = pgTable("students", {
  id: serial("id").primaryKey(),
  studentId: text("student_id").notNull().unique(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull().unique(),
  phone: text("phone"),
  dateOfBirth: date("date_of_birth"),
  // Terugzetten naar date type
  address: text("address"),
  // Oude adresveld (behouden voor compatibiliteit)
  street: text("street"),
  // Nieuwe adresvelden
  houseNumber: text("house_number"),
  postalCode: text("postal_code"),
  city: text("city"),
  programId: integer("program_id"),
  // Behouden voor backward compatibiliteit
  yearLevel: integer("year_level"),
  status: text("status").default("active"),
  // active, inactive, pending, graduated
  enrollmentDate: timestamp("enrollment_date").defaultNow(),
  notes: text("notes"),
  // Notities over de student
  gender: text("gender")
  // man of vrouw
});
var baseInsertStudentSchema = createInsertSchema(students).omit({
  id: true
});
var flexibleDateSchema = z.union([
  // Accepteer een valide date string
  z.string().transform((val) => {
    if (!val || val === "") return null;
    if (/^\d{2}-\d{2}-\d{4}$/.test(val)) {
      const [day, month, year] = val.split("-");
      const date3 = /* @__PURE__ */ new Date(`${year}-${month}-${day}`);
      if (!isNaN(date3.getTime())) return date3;
    }
    const date2 = new Date(val);
    if (!isNaN(date2.getTime())) return date2;
    return null;
  }),
  // Accepteer null
  z.null(),
  // Accepteer undefined
  z.undefined(),
  // Accepteer Date objecten
  z.date()
]).nullable().optional().catch(null);
var insertStudentSchema = baseInsertStudentSchema.extend({
  // Validatie voor alle datum velden
  dateOfBirth: flexibleDateSchema,
  enrollmentDate: flexibleDateSchema
});
var studentPrograms = pgTable("student_programs", {
  id: serial("id").primaryKey(),
  studentId: integer("student_id").notNull(),
  programId: integer("program_id").notNull(),
  yearLevel: integer("year_level"),
  enrollmentDate: timestamp("enrollment_date").defaultNow(),
  isPrimary: boolean("is_primary").default(false),
  // Geeft aan of dit het hoofdprogramma is
  status: text("status").default("active")
  // active, inactive, pending, graduated
}, (table) => {
  return {
    unq: unique().on(table.studentId, table.programId)
  };
});
var insertStudentProgramSchema = createInsertSchema(studentPrograms).omit({
  id: true
});
var programs = pgTable("programs", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  code: text("code").notNull().unique(),
  description: text("description"),
  duration: integer("duration").notNull(),
  // in years
  department: text("department").notNull(),
  isActive: boolean("is_active").default(true)
});
var insertProgramSchema = createInsertSchema(programs).omit({
  id: true
});
var courses = pgTable("courses", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  code: text("code").notNull().unique(),
  description: text("description"),
  credits: integer("credits").notNull(),
  programId: integer("program_id"),
  instructor: text("instructor"),
  maxStudents: integer("max_students"),
  isActive: boolean("is_active").default(true),
  // Nieuwe velden voor uitgebreide cursusinformatie
  learningObjectives: text("learning_objectives"),
  // Lesdoelen
  materials: text("materials"),
  // Benodigde lesmaterialen
  competencies: text("competencies"),
  // Eindcompetenties wat studenten moeten kunnen
  prerequisites: text("prerequisites")
  // Voorwaarden voor deelname
});
var insertCourseSchema = createInsertSchema(courses).omit({
  id: true
});
var enrollments = pgTable("enrollments", {
  id: serial("id").primaryKey(),
  studentId: integer("student_id").notNull(),
  courseId: integer("course_id").notNull(),
  enrollmentDate: timestamp("enrollment_date").defaultNow(),
  status: text("status").default("active")
  // active, dropped, completed
}, (table) => {
  return {
    unq: unique().on(table.studentId, table.courseId)
  };
});
var insertEnrollmentSchema = createInsertSchema(enrollments).omit({
  id: true
});
var attendance = pgTable("attendance", {
  id: serial("id").primaryKey(),
  studentId: integer("student_id").notNull(),
  courseId: integer("course_id").notNull(),
  teacherId: integer("teacher_id").notNull(),
  // Docent die de aanwezigheid bijhoudt
  date: date("date").notNull(),
  status: text("status").notNull(),
  // aanwezig, afwezig, te laat
  notes: text("notes")
}, (table) => {
  return {
    unq: unique().on(table.studentId, table.courseId, table.date)
  };
});
var insertAttendanceSchema = createInsertSchema(attendance).omit({
  id: true
});
var teacherAttendance = pgTable("teacher_attendance", {
  id: serial("id").primaryKey(),
  teacherId: integer("teacher_id").notNull(),
  // De docent waarvan de aanwezigheid wordt bijgehouden
  courseId: integer("course_id").notNull(),
  date: date("date").notNull(),
  status: text("status").notNull(),
  // aanwezig, afwezig, vervangen
  replacementTeacherId: integer("replacement_teacher_id"),
  // Indien vervangen, door welke docent
  notes: text("notes")
}, (table) => {
  return {
    unq: unique().on(table.teacherId, table.courseId, table.date)
  };
});
var insertTeacherAttendanceSchema = createInsertSchema(teacherAttendance).omit({
  id: true
});
var grades = pgTable("grades", {
  id: serial("id").primaryKey(),
  studentId: integer("student_id").notNull(),
  courseId: integer("course_id").notNull(),
  assessmentType: text("assessment_type").notNull(),
  // midterm, final, assignment, project, quiz
  assessmentName: text("assessment_name").notNull(),
  score: integer("score").notNull(),
  maxScore: integer("max_score").notNull(),
  weight: integer("weight").notNull(),
  // percentage weight in final grade
  date: date("date").notNull(),
  remark: text("remark"),
  // feedback or comments
  outOf: integer("out_of")
  // alternative to maxScore for some assessment types
});
var insertGradeSchema = createInsertSchema(grades).omit({
  id: true
});
var behaviorAssessments = pgTable("behavior_assessments", {
  id: serial("id").primaryKey(),
  studentId: integer("student_id").notNull(),
  classId: integer("class_id").notNull(),
  // student_groups id
  date: date("date").notNull(),
  behaviorScore: integer("behavior_score").notNull(),
  // 1-5 score
  punctualityScore: integer("punctuality_score"),
  // 1-5 score (optional, calculated)
  remarks: text("remarks"),
  // feedback or comments
  createdAt: timestamp("created_at").defaultNow()
});
var insertBehaviorAssessmentSchema = createInsertSchema(behaviorAssessments).omit({
  id: true,
  createdAt: true
});
var assessments = pgTable("assessments", {
  id: serial("id").primaryKey(),
  courseId: integer("course_id").notNull(),
  // foreign key to courses
  name: text("name").notNull(),
  // Name of the assessment
  type: text("type").notNull(),
  // Type: midterm, final, assignment, project, quiz
  maxScore: integer("max_score").notNull(),
  // Maximum possible score
  weight: integer("weight").notNull(),
  // Percentage weight in final grade
  dueDate: date("due_date"),
  // When the assessment is due
  description: text("description"),
  // Optional description
  createdAt: timestamp("created_at").defaultNow().notNull()
});
var insertAssessmentSchema = createInsertSchema(assessments).omit({
  id: true,
  createdAt: true
});
var events = pgTable("events", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description"),
  startDate: timestamp("start_date").notNull(),
  endDate: timestamp("end_date").notNull(),
  location: text("location"),
  type: text("type").notNull(),
  // academic, exam, holiday, meeting, other
  isAllDay: boolean("is_all_day").default(false)
});
var insertEventSchema = createInsertSchema(events).omit({
  id: true
});
var users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull().unique(),
  role: text("role").notNull(),
  // admin, teacher, staff
  isActive: boolean("is_active").default(true)
});
var insertUserSchema = createInsertSchema(users).omit({
  id: true
});
var fees = pgTable("fees", {
  id: serial("id").primaryKey(),
  studentId: integer("student_id").notNull(),
  invoiceNumber: text("invoice_number").notNull().unique(),
  description: text("description").notNull(),
  amount: decimal("amount", { precision: 10, scale: 2 }).notNull(),
  originalAmount: decimal("original_amount", { precision: 10, scale: 2 }),
  // Het originele bedrag voor korting
  discountId: integer("discount_id"),
  // Koppeling naar kortingsregel als die is toegepast
  discountAmount: decimal("discount_amount", { precision: 10, scale: 2 }),
  // Kortingsbedrag
  dueDate: date("due_date").notNull(),
  paymentDate: date("payment_date"),
  paidAmount: decimal("paid_amount", { precision: 10, scale: 2 }),
  // Hoeveel er al betaald is (voor gedeeltelijke betalingen)
  status: text("status").notNull().default("niet betaald"),
  // niet betaald, betaald, te laat, gedeeltelijk betaald, geannuleerd
  paymentMethod: text("payment_method"),
  // bank, contant, online, etc.
  academicYear: text("academic_year"),
  semester: text("semester"),
  notes: text("notes"),
  // Notities over betaling
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var feeDiscounts = pgTable("fee_discounts", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  // Naam van de korting (bijv. "Vroegboekkorting")
  description: text("description"),
  // Beschrijving van de korting
  discountType: text("discount_type").notNull(),
  // percentage, vast bedrag
  discountValue: decimal("discount_value", { precision: 10, scale: 2 }).notNull(),
  // Percentage of bedrag
  academicYear: text("academic_year").notNull(),
  // Voor welk academisch jaar geldt deze korting
  startDate: date("start_date"),
  // Vanaf wanneer is de korting geldig
  endDate: date("end_date"),
  // Tot wanneer is de korting geldig
  applicableToAll: boolean("applicable_to_all").default(false),
  // Geldt voor alle studenten
  minStudentsPerFamily: integer("min_students_per_family"),
  // Minimum aantal studenten per familie voor familiekorting
  isActive: boolean("is_active").default(true)
  // Is de korting actief
});
var feeSettings = pgTable("fee_settings", {
  id: serial("id").primaryKey(),
  academicYear: text("academic_year").notNull().unique(),
  // Academisch jaar (bijv. "2025-2026")
  standardTuition: decimal("standard_tuition", { precision: 10, scale: 2 }).notNull(),
  // Standaard collegegeld
  registrationFee: decimal("registration_fee", { precision: 10, scale: 2 }),
  // Inschrijfgeld voor nieuwe studenten
  materialsFee: decimal("materials_fee", { precision: 10, scale: 2 }),
  // Kosten voor lesmateriaal
  dueDate: date("due_date"),
  // Standaard vervaldatum voor facturen
  earlyPaymentDate: date("early_payment_date"),
  // Datum voor vroegboekkorting
  earlyPaymentDiscount: decimal("early_payment_discount", { precision: 10, scale: 2 }),
  // Bedrag vroegboekkorting
  lateFee: decimal("late_fee", { precision: 10, scale: 2 }),
  // Kosten voor te late betaling
  notes: text("notes"),
  // Notities over collegegeld voor dit jaar
  isActive: boolean("is_active").default(true)
  // Is deze instelling actief
});
var insertFeeSchema = createInsertSchema(fees).omit({
  id: true,
  createdAt: true,
  updatedAt: true
});
var insertFeeDiscountSchema = createInsertSchema(feeDiscounts).omit({
  id: true
});
var insertFeeSettingsSchema = createInsertSchema(feeSettings).omit({
  id: true
});
var studentGroups = pgTable("student_groups", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  // Naam van de groep/klas
  academicYear: text("academic_year").notNull(),
  // Academisch jaar (bijv. "2024-2025")
  programId: integer("program_id"),
  // Gekoppeld aan een studierichting
  description: text("description"),
  courseId: integer("course_id"),
  // Optioneel gekoppeld aan een specifieke cursus
  instructor: text("instructor"),
  // Verantwoordelijke docent
  startDate: date("start_date"),
  endDate: date("end_date"),
  maxCapacity: integer("max_capacity"),
  isActive: boolean("is_active").default(true)
});
var insertStudentGroupSchema = createInsertSchema(studentGroups).omit({
  id: true
});
var studentGroupEnrollments = pgTable("student_group_enrollments", {
  id: serial("id").primaryKey(),
  studentId: integer("student_id").notNull(),
  groupId: integer("group_id").notNull(),
  // Verwijst naar student_groups.id
  enrollmentDate: timestamp("enrollment_date").defaultNow(),
  status: text("status").default("active"),
  // active, inactive, completed
  notes: text("notes")
}, (table) => {
  return {
    unq: unique().on(table.studentId, table.groupId)
  };
});
var insertStudentGroupEnrollmentSchema = createInsertSchema(studentGroupEnrollments).omit({
  id: true
});
var lessons = pgTable("lessons", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  courseId: integer("course_id").notNull(),
  groupId: integer("group_id"),
  // Optioneel gekoppeld aan een studentengroep
  scheduledDate: timestamp("scheduled_date").notNull(),
  endTime: timestamp("end_time").notNull(),
  location: text("location"),
  instructor: text("instructor"),
  description: text("description"),
  lessonMaterials: text("lesson_materials"),
  // URL of verwijzing naar lesmateriaal
  status: text("status").default("scheduled")
  // scheduled, completed, cancelled
});
var insertLessonSchema = createInsertSchema(lessons).omit({
  id: true
});
var examinations = pgTable("examinations", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  courseId: integer("course_id").notNull(),
  assessmentId: integer("assessment_id"),
  // Gekoppeld aan de beoordelingsstructuur
  examDate: timestamp("exam_date").notNull(),
  endTime: timestamp("end_time").notNull(),
  location: text("location"),
  supervisor: text("supervisor"),
  // Toezichthouder
  maxScore: integer("max_score").notNull(),
  duration: integer("duration").notNull(),
  // Duur in minuten
  format: text("format").notNull(),
  // written, oral, practical, online
  instructions: text("instructions"),
  // Specifieke instructies
  status: text("status").default("scheduled")
  // scheduled, in-progress, completed, cancelled
});
var insertExaminationSchema = createInsertSchema(examinations).omit({
  id: true
});
var guardians = pgTable("guardians", {
  id: serial("id").primaryKey(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  relationship: text("relationship").notNull(),
  // parent, guardian, other
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  address: text("address"),
  // Oude adresveld (behouden voor compatibiliteit)
  street: text("street"),
  // Nieuwe adresvelden
  houseNumber: text("house_number"),
  postalCode: text("postal_code"),
  city: text("city"),
  occupation: text("occupation"),
  isEmergencyContact: boolean("is_emergency_contact").default(false),
  notes: text("notes")
});
var insertGuardianSchema = createInsertSchema(guardians).omit({
  id: true
});
var studentGuardians = pgTable("student_guardians", {
  id: serial("id").primaryKey(),
  studentId: integer("student_id").notNull(),
  guardianId: integer("guardian_id").notNull(),
  isPrimary: boolean("is_primary").default(false)
  // Primaire contactpersoon
}, (table) => {
  return {
    unq: unique().on(table.studentId, table.guardianId)
  };
});
var insertStudentGuardianSchema = createInsertSchema(studentGuardians).omit({
  id: true
});
var studentsRelations = relations(students, ({ many }) => ({
  studentPrograms: many(studentPrograms),
  enrollments: many(enrollments),
  studentGuardians: many(studentGuardians)
}));
var studentProgramsRelations = relations(studentPrograms, ({ one }) => ({
  student: one(students, {
    fields: [studentPrograms.studentId],
    references: [students.id]
  }),
  program: one(programs, {
    fields: [studentPrograms.programId],
    references: [programs.id]
  })
}));
var programsRelations = relations(programs, ({ many }) => ({
  courses: many(courses),
  studentPrograms: many(studentPrograms)
}));
var studentGuardiansRelations = relations(studentGuardians, ({ one }) => ({
  student: one(students, {
    fields: [studentGuardians.studentId],
    references: [students.id]
  }),
  guardian: one(guardians, {
    fields: [studentGuardians.guardianId],
    references: [guardians.id]
  })
}));
var guardiansRelations = relations(guardians, ({ many }) => ({
  studentGuardians: many(studentGuardians)
}));
var teachers = pgTable("teachers", {
  id: serial("id").primaryKey(),
  teacherId: text("teacher_id").notNull().unique(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  gender: text("gender"),
  email: text("email").notNull().unique(),
  phone: text("phone"),
  dateOfBirth: date("date_of_birth"),
  address: text("address"),
  street: text("street"),
  houseNumber: text("house_number"),
  postalCode: text("postal_code"),
  city: text("city"),
  isActive: boolean("is_active").default(true),
  hireDate: date("hire_date"),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var insertTeacherSchema = createInsertSchema(teachers).omit({
  id: true,
  createdAt: true,
  updatedAt: true
});
var teacherAvailability = pgTable("teacher_availability", {
  id: serial("id").primaryKey(),
  teacherId: integer("teacher_id").notNull().references(() => teachers.id),
  dayOfWeek: integer("day_of_week").notNull(),
  // 0 = zondag, 1 = maandag, etc.
  startTime: text("start_time").notNull(),
  // format: "HH:MM"
  endTime: text("end_time").notNull(),
  // format: "HH:MM"
  isBackup: boolean("is_backup").default(false),
  notes: text("notes")
});
var insertTeacherAvailabilitySchema = createInsertSchema(teacherAvailability).omit({
  id: true
});
var teacherLanguages = pgTable("teacher_languages", {
  id: serial("id").primaryKey(),
  teacherId: integer("teacher_id").notNull().references(() => teachers.id),
  language: text("language").notNull(),
  proficiencyLevel: text("proficiency_level").notNull()
  // beginner, intermediate, advanced, native
});
var insertTeacherLanguageSchema = createInsertSchema(teacherLanguages).omit({
  id: true
});
var teacherCourseAssignments = pgTable("teacher_course_assignments", {
  id: serial("id").primaryKey(),
  teacherId: integer("teacher_id").notNull().references(() => teachers.id),
  courseId: integer("course_id").notNull().references(() => courses.id),
  isPrimary: boolean("is_primary").default(false),
  startDate: date("start_date"),
  endDate: date("end_date"),
  notes: text("notes")
});
var insertTeacherCourseAssignmentSchema = createInsertSchema(teacherCourseAssignments).omit({
  id: true
});
var teachersRelations = relations(teachers, ({ many }) => ({
  availability: many(teacherAvailability),
  languages: many(teacherLanguages),
  courseAssignments: many(teacherCourseAssignments),
  attendance: many(teacherAttendance),
  studentAttendance: many(attendance, { relationName: "recordedAttendance" })
}));
var teacherAvailabilityRelations = relations(teacherAvailability, ({ one }) => ({
  teacher: one(teachers, {
    fields: [teacherAvailability.teacherId],
    references: [teachers.id]
  })
}));
var teacherLanguagesRelations = relations(teacherLanguages, ({ one }) => ({
  teacher: one(teachers, {
    fields: [teacherLanguages.teacherId],
    references: [teachers.id]
  })
}));
var teacherCourseAssignmentsRelations = relations(teacherCourseAssignments, ({ one }) => ({
  teacher: one(teachers, {
    fields: [teacherCourseAssignments.teacherId],
    references: [teachers.id]
  }),
  course: one(courses, {
    fields: [teacherCourseAssignments.courseId],
    references: [courses.id]
  })
}));
var attendanceRelations = relations(attendance, ({ one }) => ({
  student: one(students, {
    fields: [attendance.studentId],
    references: [students.id]
  }),
  course: one(courses, {
    fields: [attendance.courseId],
    references: [courses.id]
  }),
  teacher: one(teachers, {
    fields: [attendance.teacherId],
    references: [teachers.id],
    relationName: "recordedAttendance"
  })
}));
var teacherAttendanceRelations = relations(teacherAttendance, ({ one }) => ({
  teacher: one(teachers, {
    fields: [teacherAttendance.teacherId],
    references: [teachers.id]
  }),
  course: one(courses, {
    fields: [teacherAttendance.courseId],
    references: [courses.id]
  }),
  replacementTeacher: one(teachers, {
    fields: [teacherAttendance.replacementTeacherId],
    references: [teachers.id],
    relationName: "replacements"
  })
}));

// server/db.ts
neonConfig.webSocketConstructor = ws;
if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL moet ingesteld zijn. Heb je vergeten een database toe te voegen?"
  );
}
var poolInstance = null;
function getPool() {
  if (!poolInstance) {
    poolInstance = new Pool({
      connectionString: process.env.DATABASE_URL,
      max: 1
      // Beperkt aantal verbindingen voor serverless
    });
  }
  return poolInstance;
}
var pool = getPool();
var db = drizzle(pool, { schema: schema_exports });

// server/storage/databaseStorage.ts
var DatabaseStorage = class {
  // Student operations
  async getStudents() {
    return db.select().from(students);
  }
  async getStudent(id) {
    const result = await db.select().from(students).where(eq(students.id, id));
    return result[0];
  }
  async getStudentByEmail(email) {
    const result = await db.select().from(students).where(eq(students.email, email));
    return result[0];
  }
  async createStudent(student) {
    const result = await db.insert(students).values(student).returning();
    return result[0];
  }
  async updateStudent(id, student) {
    const result = await db.update(students).set(student).where(eq(students.id, id)).returning();
    return result[0];
  }
  async deleteStudent(id) {
    const result = await db.delete(students).where(eq(students.id, id)).returning({ id: students.id });
    return result.length > 0;
  }
  // Program operations
  async getPrograms() {
    return db.select().from(programs);
  }
  async getProgram(id) {
    const result = await db.select().from(programs).where(eq(programs.id, id));
    return result[0];
  }
  async getProgramByCode(code) {
    const result = await db.select().from(programs).where(eq(programs.code, code));
    return result[0];
  }
  async createProgram(program) {
    const result = await db.insert(programs).values(program).returning();
    return result[0];
  }
  async updateProgram(id, program) {
    const result = await db.update(programs).set(program).where(eq(programs.id, id)).returning();
    return result[0];
  }
  async deleteProgram(id) {
    const result = await db.delete(programs).where(eq(programs.id, id)).returning({ id: programs.id });
    return result.length > 0;
  }
  // Course operations
  async getCourses() {
    return db.select().from(courses);
  }
  async getCourse(id) {
    const result = await db.select().from(courses).where(eq(courses.id, id));
    return result[0];
  }
  async getCourseByCode(code) {
    const result = await db.select().from(courses).where(eq(courses.code, code));
    return result[0];
  }
  async getCoursesByProgram(programId) {
    return db.select().from(courses).where(eq(courses.programId, programId));
  }
  async getCoursesByFilter(filter) {
    const allCourses = await db.select().from(courses);
    if (filter.isActive !== void 0) {
      return allCourses.filter((course) => course.isActive === filter.isActive);
    }
    return allCourses;
  }
  async createCourse(course) {
    const result = await db.insert(courses).values(course).returning();
    return result[0];
  }
  async updateCourse(id, course) {
    const result = await db.update(courses).set(course).where(eq(courses.id, id)).returning();
    return result[0];
  }
  async deleteCourse(id) {
    const result = await db.delete(courses).where(eq(courses.id, id)).returning({ id: courses.id });
    return result.length > 0;
  }
  // Enrollment operations
  async getEnrollments() {
    return db.select().from(enrollments);
  }
  async getEnrollment(id) {
    const result = await db.select().from(enrollments).where(eq(enrollments.id, id));
    return result[0];
  }
  async getEnrollmentsByStudent(studentId) {
    return db.select().from(enrollments).where(eq(enrollments.studentId, studentId));
  }
  async getEnrollmentsByCourse(courseId) {
    return db.select().from(enrollments).where(eq(enrollments.courseId, courseId));
  }
  async createEnrollment(enrollment) {
    const result = await db.insert(enrollments).values(enrollment).returning();
    return result[0];
  }
  async updateEnrollment(id, enrollment) {
    const result = await db.update(enrollments).set(enrollment).where(eq(enrollments.id, id)).returning();
    return result[0];
  }
  async deleteEnrollment(id) {
    const result = await db.delete(enrollments).where(eq(enrollments.id, id)).returning({ id: enrollments.id });
    return result.length > 0;
  }
  // Attendance operations
  async getAttendanceRecords() {
    return db.select().from(attendance);
  }
  async getAttendanceRecord(id) {
    const result = await db.select().from(attendance).where(eq(attendance.id, id));
    return result[0];
  }
  async getAttendanceByStudent(studentId) {
    return db.select().from(attendance).where(eq(attendance.studentId, studentId));
  }
  async getAttendanceByCourse(courseId) {
    return db.select().from(attendance).where(eq(attendance.courseId, courseId));
  }
  async getAttendanceByDate(date2) {
    const dateString = date2.toISOString().split("T")[0];
    const records = await db.select().from(attendance);
    return records.filter((record) => {
      const recordDate = record.date.split("T")[0];
      return recordDate === dateString;
    });
  }
  async createAttendance(attendanceData) {
    const result = await db.insert(attendance).values(attendanceData).returning();
    return result[0];
  }
  async updateAttendance(id, attendanceData) {
    const result = await db.update(attendance).set(attendanceData).where(eq(attendance.id, id)).returning();
    return result[0];
  }
  async deleteAttendance(id) {
    const result = await db.delete(attendance).where(eq(attendance.id, id)).returning({ id: attendance.id });
    return result.length > 0;
  }
  // Assessment operations
  async getAssessments() {
    return db.select().from(assessments);
  }
  async getAssessment(id) {
    const result = await db.select().from(assessments).where(eq(assessments.id, id));
    return result[0];
  }
  async getAssessmentsByCourse(courseId) {
    return db.select().from(assessments).where(eq(assessments.courseId, courseId));
  }
  async createAssessment(assessment) {
    const result = await db.insert(assessments).values(assessment).returning();
    return result[0];
  }
  async updateAssessment(id, assessment) {
    const result = await db.update(assessments).set(assessment).where(eq(assessments.id, id)).returning();
    return result[0];
  }
  async deleteAssessment(id) {
    const result = await db.delete(assessments).where(eq(assessments.id, id)).returning({ id: assessments.id });
    return result.length > 0;
  }
  // Grade operations
  async getGrades() {
    return db.select().from(grades);
  }
  async getGrade(id) {
    const result = await db.select().from(grades).where(eq(grades.id, id));
    return result[0];
  }
  async getGradesByStudent(studentId) {
    return db.select().from(grades).where(eq(grades.studentId, studentId));
  }
  async getGradesByCourse(courseId) {
    return db.select().from(grades).where(eq(grades.courseId, courseId));
  }
  async getGradesByAssessment(assessmentType) {
    return db.select().from(grades).where(eq(grades.assessmentType, assessmentType.toString()));
  }
  async getGradesByStudentAndCourse(studentId, courseId) {
    const allGrades = await db.select().from(grades);
    return allGrades.filter((grade) => grade.studentId === studentId && grade.courseId === courseId);
  }
  async batchCreateGrades(insertGrades) {
    if (insertGrades.length === 0) return [];
    const results = [];
    for (const grade of insertGrades) {
      const result = await db.insert(grades).values(grade).returning();
      if (result.length > 0) {
        results.push(result[0]);
      }
    }
    return results;
  }
  async createGrade(grade) {
    const result = await db.insert(grades).values(grade).returning();
    return result[0];
  }
  async updateGrade(id, grade) {
    const result = await db.update(grades).set(grade).where(eq(grades.id, id)).returning();
    return result[0];
  }
  async deleteGrade(id) {
    const result = await db.delete(grades).where(eq(grades.id, id)).returning({ id: grades.id });
    return result.length > 0;
  }
  // Event operations
  async getEvents() {
    return db.select().from(events);
  }
  async getEvent(id) {
    const result = await db.select().from(events).where(eq(events.id, id));
    return result[0];
  }
  async getEventsByDateRange(startDate, endDate) {
    const allEvents = await db.select().from(events);
    return allEvents.filter((event) => {
      const eventStart = new Date(event.startDate);
      const eventEnd = new Date(event.endDate);
      return eventStart >= startDate && eventStart <= endDate || eventEnd >= startDate && eventEnd <= endDate || eventStart <= startDate && eventEnd >= endDate;
    });
  }
  async createEvent(event) {
    const result = await db.insert(events).values(event).returning();
    return result[0];
  }
  async updateEvent(id, event) {
    const result = await db.update(events).set(event).where(eq(events.id, id)).returning();
    return result[0];
  }
  async deleteEvent(id) {
    const result = await db.delete(events).where(eq(events.id, id)).returning({ id: events.id });
    return result.length > 0;
  }
  // User operations
  async getUsers() {
    return db.select().from(users);
  }
  async getUser(id) {
    const result = await db.select().from(users).where(eq(users.id, id));
    return result[0];
  }
  async getUserByUsername(username) {
    const result = await db.select().from(users).where(eq(users.username, username));
    return result[0];
  }
  async createUser(user) {
    const result = await db.insert(users).values(user).returning();
    return result[0];
  }
  async updateUser(id, user) {
    const result = await db.update(users).set(user).where(eq(users.id, id)).returning();
    return result[0];
  }
  async deleteUser(id) {
    const result = await db.delete(users).where(eq(users.id, id)).returning({ id: users.id });
    return result.length > 0;
  }
  // Fee operations
  async getFees() {
    return db.select().from(fees);
  }
  async getFee(id) {
    const result = await db.select().from(fees).where(eq(fees.id, id));
    return result[0];
  }
  async getFeesByStudent(studentId) {
    return db.select().from(fees).where(eq(fees.studentId, studentId));
  }
  async getFeesByStatus(status) {
    return db.select().from(fees).where(eq(fees.status, status));
  }
  async getFeesByDateRange(startDate, endDate) {
    const startDateStr = startDate.toISOString().split("T")[0];
    const endDateStr = endDate.toISOString().split("T")[0];
    const allFees = await db.select().from(fees);
    return allFees.filter((fee) => {
      const dueDateStr = new Date(fee.dueDate).toISOString().split("T")[0];
      return dueDateStr >= startDateStr && dueDateStr <= endDateStr;
    });
  }
  async createFee(fee) {
    const result = await db.insert(fees).values(fee).returning();
    return result[0];
  }
  async updateFee(id, fee) {
    const result = await db.update(fees).set(fee).where(eq(fees.id, id)).returning();
    return result[0];
  }
  async deleteFee(id) {
    const result = await db.delete(fees).where(eq(fees.id, id)).returning({ id: fees.id });
    return result.length > 0;
  }
  // Student Group operations
  async getStudentGroups() {
    return db.select().from(studentGroups);
  }
  async getStudentGroup(id) {
    const result = await db.select().from(studentGroups).where(eq(studentGroups.id, id));
    return result[0];
  }
  async getStudentGroupsByProgram(programId) {
    return db.select().from(studentGroups).where(eq(studentGroups.programId, programId));
  }
  async getStudentGroupsByCourse(courseId) {
    return db.select().from(studentGroups).where(eq(studentGroups.courseId, courseId));
  }
  async getStudentGroupsByAcademicYear(academicYear) {
    return db.select().from(studentGroups).where(eq(studentGroups.academicYear, academicYear));
  }
  async createStudentGroup(group) {
    const result = await db.insert(studentGroups).values(group).returning();
    return result[0];
  }
  async updateStudentGroup(id, group) {
    const result = await db.update(studentGroups).set(group).where(eq(studentGroups.id, id)).returning();
    return result[0];
  }
  async deleteStudentGroup(id) {
    const result = await db.delete(studentGroups).where(eq(studentGroups.id, id)).returning({ id: studentGroups.id });
    return result.length > 0;
  }
  // Student Group Enrollment operations
  async getStudentGroupEnrollments() {
    return db.select().from(studentGroupEnrollments);
  }
  async getStudentGroupEnrollment(id) {
    const result = await db.select().from(studentGroupEnrollments).where(eq(studentGroupEnrollments.id, id));
    return result[0];
  }
  async getStudentGroupEnrollmentsByStudent(studentId) {
    return db.select().from(studentGroupEnrollments).where(eq(studentGroupEnrollments.studentId, studentId));
  }
  async getStudentGroupEnrollmentsByGroup(groupId) {
    return db.select().from(studentGroupEnrollments).where(eq(studentGroupEnrollments.groupId, groupId));
  }
  async createStudentGroupEnrollment(enrollment) {
    const result = await db.insert(studentGroupEnrollments).values(enrollment).returning();
    return result[0];
  }
  async updateStudentGroupEnrollment(id, enrollment) {
    const result = await db.update(studentGroupEnrollments).set(enrollment).where(eq(studentGroupEnrollments.id, id)).returning();
    return result[0];
  }
  async deleteStudentGroupEnrollment(id) {
    const result = await db.delete(studentGroupEnrollments).where(eq(studentGroupEnrollments.id, id)).returning({ id: studentGroupEnrollments.id });
    return result.length > 0;
  }
  // Lesson operations
  async getLessons() {
    return db.select().from(lessons);
  }
  async getLesson(id) {
    const result = await db.select().from(lessons).where(eq(lessons.id, id));
    return result[0];
  }
  async getLessonsByCourse(courseId) {
    return db.select().from(lessons).where(eq(lessons.courseId, courseId));
  }
  async getLessonsByGroup(groupId) {
    return db.select().from(lessons).where(eq(lessons.groupId, groupId));
  }
  async getLessonsByDateRange(startDate, endDate) {
    const allLessons = await db.select().from(lessons);
    return allLessons.filter((lesson) => {
      const lessonDate = new Date(lesson.scheduledDate);
      return lessonDate >= startDate && lessonDate <= endDate;
    });
  }
  async createLesson(lesson) {
    const result = await db.insert(lessons).values(lesson).returning();
    return result[0];
  }
  async updateLesson(id, lesson) {
    const result = await db.update(lessons).set(lesson).where(eq(lessons.id, id)).returning();
    return result[0];
  }
  async deleteLesson(id) {
    const result = await db.delete(lessons).where(eq(lessons.id, id)).returning({ id: lessons.id });
    return result.length > 0;
  }
  // Examination operations
  async getExaminations() {
    return db.select().from(examinations);
  }
  async getExamination(id) {
    const result = await db.select().from(examinations).where(eq(examinations.id, id));
    return result[0];
  }
  async getExaminationsByCourse(courseId) {
    return db.select().from(examinations).where(eq(examinations.courseId, courseId));
  }
  async getExaminationsByDateRange(startDate, endDate) {
    const allExams = await db.select().from(examinations);
    return allExams.filter((exam) => {
      const examDate = new Date(exam.examDate);
      return examDate >= startDate && examDate <= endDate;
    });
  }
  async getExaminationsByAssessment(assessmentId) {
    return db.select().from(examinations).where(eq(examinations.assessmentId, assessmentId));
  }
  async createExamination(examination) {
    const result = await db.insert(examinations).values(examination).returning();
    return result[0];
  }
  async updateExamination(id, examination) {
    const result = await db.update(examinations).set(examination).where(eq(examinations.id, id)).returning();
    return result[0];
  }
  async deleteExamination(id) {
    const result = await db.delete(examinations).where(eq(examinations.id, id)).returning({ id: examinations.id });
    return result.length > 0;
  }
  // Guardian operations
  async getGuardians() {
    return db.select().from(guardians);
  }
  async getGuardian(id) {
    const result = await db.select().from(guardians).where(eq(guardians.id, id));
    return result[0];
  }
  async getGuardianByEmail(email) {
    const result = await db.select().from(guardians).where(eq(guardians.email, email));
    return result[0];
  }
  async getGuardiansByStudent(studentId) {
    const relations2 = await db.select().from(studentGuardians).where(eq(studentGuardians.studentId, studentId));
    if (relations2.length === 0) return [];
    const guardianIds = relations2.map((relation) => relation.guardianId);
    const allGuardians = await db.select().from(guardians);
    return allGuardians.filter((guardian) => guardianIds.includes(guardian.id));
  }
  async createGuardian(guardian) {
    const result = await db.insert(guardians).values(guardian).returning();
    return result[0];
  }
  async updateGuardian(id, guardian) {
    const result = await db.update(guardians).set(guardian).where(eq(guardians.id, id)).returning();
    return result[0];
  }
  async deleteGuardian(id) {
    const result = await db.delete(guardians).where(eq(guardians.id, id)).returning({ id: guardians.id });
    return result.length > 0;
  }
  // Student Guardian operations
  async getStudentGuardians() {
    return db.select().from(studentGuardians);
  }
  async getStudentGuardian(id) {
    const result = await db.select().from(studentGuardians).where(eq(studentGuardians.id, id));
    return result[0];
  }
  async getStudentGuardiansByStudent(studentId) {
    return db.select().from(studentGuardians).where(eq(studentGuardians.studentId, studentId));
  }
  async getStudentGuardiansByGuardian(guardianId) {
    return db.select().from(studentGuardians).where(eq(studentGuardians.guardianId, guardianId));
  }
  async createStudentGuardian(relation) {
    const result = await db.insert(studentGuardians).values(relation).returning();
    return result[0];
  }
  async updateStudentGuardian(id, relation) {
    const result = await db.update(studentGuardians).set(relation).where(eq(studentGuardians.id, id)).returning();
    return result[0];
  }
  async deleteStudentGuardian(id) {
    const result = await db.delete(studentGuardians).where(eq(studentGuardians.id, id)).returning({ id: studentGuardians.id });
    return result.length > 0;
  }
  // Student Program operations
  async getStudentPrograms() {
    return db.select().from(studentPrograms);
  }
  async getStudentProgram(id) {
    const result = await db.select().from(studentPrograms).where(eq(studentPrograms.id, id));
    return result[0];
  }
  async getStudentProgramsByStudent(studentId) {
    return db.select().from(studentPrograms).where(eq(studentPrograms.studentId, studentId));
  }
  async getStudentProgramsByProgram(programId) {
    return db.select().from(studentPrograms).where(eq(studentPrograms.programId, programId));
  }
  async createStudentProgram(studentProgram) {
    if (studentProgram.isPrimary) {
      await db.update(studentPrograms).set({ isPrimary: false }).where(eq(studentPrograms.studentId, studentProgram.studentId));
    }
    const result = await db.insert(studentPrograms).values(studentProgram).returning();
    return result[0];
  }
  async updateStudentProgram(id, studentProgram) {
    if (studentProgram.isPrimary) {
      const currentProgram = await this.getStudentProgram(id);
      if (currentProgram) {
        await db.update(studentPrograms).set({ isPrimary: false }).where(eq(studentPrograms.studentId, currentProgram.studentId));
      }
    }
    const result = await db.update(studentPrograms).set(studentProgram).where(eq(studentPrograms.id, id)).returning();
    return result[0];
  }
  async deleteStudentProgram(id) {
    const result = await db.delete(studentPrograms).where(eq(studentPrograms.id, id)).returning({ id: studentPrograms.id });
    return result.length > 0;
  }
  async getPrimaryProgramByStudent(studentId) {
    const result = await db.select().from(studentPrograms).where(and(
      eq(studentPrograms.studentId, studentId),
      eq(studentPrograms.isPrimary, true)
    ));
    if (result.length > 0) {
      return result[0];
    }
    return void 0;
  }
  // Teacher operations
  async getTeachers() {
    return db.select().from(teachers);
  }
  async getTeacher(id) {
    const result = await db.select().from(teachers).where(eq(teachers.id, id));
    return result[0];
  }
  async getTeacherByEmail(email) {
    const result = await db.select().from(teachers).where(eq(teachers.email, email));
    return result[0];
  }
  async createTeacher(teacher) {
    const result = await db.insert(teachers).values(teacher).returning();
    return result[0];
  }
  async updateTeacher(id, teacher) {
    const result = await db.update(teachers).set(teacher).where(eq(teachers.id, id)).returning();
    return result[0];
  }
  async deleteTeacher(id) {
    const result = await db.delete(teachers).where(eq(teachers.id, id)).returning({ id: teachers.id });
    return result.length > 0;
  }
  // Teacher Availability operations
  async getTeacherAvailabilities() {
    return db.select().from(teacherAvailability);
  }
  async getTeacherAvailability(id) {
    const result = await db.select().from(teacherAvailability).where(eq(teacherAvailability.id, id));
    return result[0];
  }
  async getTeacherAvailabilitiesByTeacher(teacherId) {
    return db.select().from(teacherAvailability).where(eq(teacherAvailability.teacherId, teacherId));
  }
  async createTeacherAvailability(availability) {
    const result = await db.insert(teacherAvailability).values(availability).returning();
    return result[0];
  }
  async updateTeacherAvailability(id, availability) {
    const result = await db.update(teacherAvailability).set(availability).where(eq(teacherAvailability.id, id)).returning();
    return result[0];
  }
  async deleteTeacherAvailability(id) {
    const result = await db.delete(teacherAvailability).where(eq(teacherAvailability.id, id)).returning({ id: teacherAvailability.id });
    return result.length > 0;
  }
  // Teacher Language operations
  async getTeacherLanguages() {
    return db.select().from(teacherLanguages);
  }
  async getTeacherLanguage(id) {
    const result = await db.select().from(teacherLanguages).where(eq(teacherLanguages.id, id));
    return result[0];
  }
  async getTeacherLanguagesByTeacher(teacherId) {
    return db.select().from(teacherLanguages).where(eq(teacherLanguages.teacherId, teacherId));
  }
  async createTeacherLanguage(language) {
    const result = await db.insert(teacherLanguages).values(language).returning();
    return result[0];
  }
  async updateTeacherLanguage(id, language) {
    const result = await db.update(teacherLanguages).set(language).where(eq(teacherLanguages.id, id)).returning();
    return result[0];
  }
  async deleteTeacherLanguage(id) {
    const result = await db.delete(teacherLanguages).where(eq(teacherLanguages.id, id)).returning({ id: teacherLanguages.id });
    return result.length > 0;
  }
  // Teacher Course Assignment operations
  async getTeacherCourseAssignments() {
    return db.select().from(teacherCourseAssignments);
  }
  async getTeacherCourseAssignment(id) {
    const result = await db.select().from(teacherCourseAssignments).where(eq(teacherCourseAssignments.id, id));
    return result[0];
  }
  async getTeacherCourseAssignmentsByTeacher(teacherId) {
    return db.select().from(teacherCourseAssignments).where(eq(teacherCourseAssignments.teacherId, teacherId));
  }
  async getTeacherCourseAssignmentsByCourse(courseId) {
    return db.select().from(teacherCourseAssignments).where(eq(teacherCourseAssignments.courseId, courseId));
  }
  async createTeacherCourseAssignment(assignment) {
    const result = await db.insert(teacherCourseAssignments).values(assignment).returning();
    return result[0];
  }
  async updateTeacherCourseAssignment(id, assignment) {
    const result = await db.update(teacherCourseAssignments).set(assignment).where(eq(teacherCourseAssignments.id, id)).returning();
    return result[0];
  }
  async deleteTeacherCourseAssignment(id) {
    const result = await db.delete(teacherCourseAssignments).where(eq(teacherCourseAssignments.id, id)).returning({ id: teacherCourseAssignments.id });
    return result.length > 0;
  }
  // Teacher Attendance operations
  async getTeacherAttendanceRecords() {
    return db.select().from(teacherAttendance);
  }
  async getTeacherAttendanceRecord(id) {
    const result = await db.select().from(teacherAttendance).where(eq(teacherAttendance.id, id));
    return result[0];
  }
  async getTeacherAttendanceByTeacher(teacherId) {
    return db.select().from(teacherAttendance).where(eq(teacherAttendance.teacherId, teacherId));
  }
  async getTeacherAttendanceByCourse(courseId) {
    return db.select().from(teacherAttendance).where(eq(teacherAttendance.courseId, courseId));
  }
  async getTeacherAttendanceByDate(date2) {
    const dateString = date2.toISOString().split("T")[0];
    return db.select().from(teacherAttendance).where(eq(teacherAttendance.date, dateString));
  }
  async createTeacherAttendance(attendance2) {
    const result = await db.insert(teacherAttendance).values(attendance2).returning();
    return result[0];
  }
  async updateTeacherAttendance(id, attendance2) {
    const result = await db.update(teacherAttendance).set(attendance2).where(eq(teacherAttendance.id, id)).returning();
    return result[0];
  }
  async deleteTeacherAttendance(id) {
    const result = await db.delete(teacherAttendance).where(eq(teacherAttendance.id, id)).returning({ id: teacherAttendance.id });
    return result.length > 0;
  }
  // Enhanced Attendance operations (with teacher)
  async getAttendanceByTeacher(teacherId) {
    return db.select().from(attendance).where(eq(attendance.teacherId, teacherId));
  }
  async getAttendanceByClassAndDate(courseId, date2) {
    const dateString = date2.toISOString().split("T")[0];
    return db.select().from(attendance).where(and(
      eq(attendance.courseId, courseId),
      eq(attendance.date, dateString)
    ));
  }
  // Behavior Assessment operations
  async getBehaviorAssessments(filter) {
    let query = db.select().from(behaviorAssessments);
    if (filter) {
      if (filter.studentId) {
        query = query.where(eq(behaviorAssessments.studentId, filter.studentId));
      }
      if (filter.classId) {
        query = query.where(eq(behaviorAssessments.classId, filter.classId));
      }
    }
    return query;
  }
  async getBehaviorAssessment(id) {
    const result = await db.select().from(behaviorAssessments).where(eq(behaviorAssessments.id, id));
    return result[0];
  }
  async getBehaviorAssessmentsByStudent(studentId) {
    return db.select().from(behaviorAssessments).where(eq(behaviorAssessments.studentId, studentId));
  }
  async getBehaviorAssessmentsByClass(classId) {
    return db.select().from(behaviorAssessments).where(eq(behaviorAssessments.classId, classId));
  }
  async createBehaviorAssessment(assessment) {
    const result = await db.insert(behaviorAssessments).values(assessment).returning();
    return result[0];
  }
  async createBehaviorAssessments(assessments2) {
    if (assessments2.length === 0) return [];
    const result = await db.insert(behaviorAssessments).values(assessments2).returning();
    return result;
  }
  async updateBehaviorAssessment(id, assessment) {
    const result = await db.update(behaviorAssessments).set(assessment).where(eq(behaviorAssessments.id, id)).returning();
    return result[0];
  }
  async deleteBehaviorAssessment(id) {
    const result = await db.delete(behaviorAssessments).where(eq(behaviorAssessments.id, id)).returning({ id: behaviorAssessments.id });
    return result.length > 0;
  }
  // Fee Stats en Outstanding Debts
  async getFeeStats() {
    try {
      const allFees = await db.select().from(fees);
      const allStudents = await db.select().from(students);
      const totalStudents = allStudents.length;
      let totalCollected = 0;
      let pendingAmount = 0;
      let overdueAmount = 0;
      let pendingInvoices = 0;
      const currentDate = (/* @__PURE__ */ new Date()).toISOString();
      allFees.forEach((fee) => {
        const amount = parseFloat(fee.amount);
        if (fee.status === "betaald") {
          totalCollected += amount;
        } else {
          pendingAmount += amount;
          pendingInvoices++;
          if (fee.dueDate < currentDate) {
            overdueAmount += amount;
          }
        }
      });
      const completionRate = allFees.length > 0 ? allFees.filter((fee) => fee.status === "betaald").length / allFees.length * 100 : 0;
      return {
        totalCollected,
        pendingAmount,
        totalStudents,
        completionRate,
        overdueAmount,
        pendingInvoices
      };
    } catch (error) {
      console.error("Error calculating fee stats:", error);
      return void 0;
    }
  }
  async getOutstandingDebts() {
    try {
      const outstandingFees = await db.select().from(fees).where(eq(fees.status, "niet betaald"));
      const result = [];
      for (const fee of outstandingFees) {
        const student = await this.getStudent(fee.studentId);
        if (student) {
          const guardianRelations = await this.getStudentGuardiansByStudent(student.id);
          const guardianInfo = [];
          for (const relation of guardianRelations) {
            const guardian = await this.getGuardian(relation.guardianId);
            if (guardian) {
              guardianInfo.push({
                id: guardian.id,
                name: `${guardian.firstName} ${guardian.lastName}`,
                email: guardian.email,
                phone: guardian.phone
              });
            }
          }
          result.push({
            id: fee.id,
            studentId: student.id,
            studentName: `${student.firstName} ${student.lastName}`,
            invoiceNumber: fee.invoiceNumber,
            amount: fee.amount,
            dueDate: fee.dueDate,
            description: fee.description,
            guardians: guardianInfo
          });
        }
      }
      return result;
    } catch (error) {
      console.error("Error fetching outstanding debts:", error);
      return [];
    }
  }
  // Fee Settings operations
  async getFeeSettings() {
    return db.select().from(feeSettings);
  }
  async getFeeSetting(id) {
    const result = await db.select().from(feeSettings).where(eq(feeSettings.id, id));
    return result[0];
  }
  async getFeeSettingByAcademicYear(academicYear) {
    const result = await db.select().from(feeSettings).where(eq(feeSettings.academicYear, academicYear));
    return result[0];
  }
  async createFeeSetting(setting) {
    const result = await db.insert(feeSettings).values(setting).returning();
    return result[0];
  }
  async updateFeeSetting(id, setting) {
    const result = await db.update(feeSettings).set(setting).where(eq(feeSettings.id, id)).returning();
    return result[0];
  }
  async deleteFeeSetting(id) {
    const result = await db.delete(feeSettings).where(eq(feeSettings.id, id)).returning({ id: feeSettings.id });
    return result.length > 0;
  }
  // Fee Discount operations
  async getFeeDiscounts() {
    return db.select().from(feeDiscounts);
  }
  async getFeeDiscount(id) {
    const result = await db.select().from(feeDiscounts).where(eq(feeDiscounts.id, id));
    return result[0];
  }
  async getFeeDiscountsByAcademicYear(academicYear) {
    return db.select().from(feeDiscounts).where(eq(feeDiscounts.academicYear, academicYear));
  }
  async createFeeDiscount(discount) {
    const result = await db.insert(feeDiscounts).values(discount).returning();
    return result[0];
  }
  async updateFeeDiscount(id, discount) {
    const result = await db.update(feeDiscounts).set(discount).where(eq(feeDiscounts.id, id)).returning();
    return result[0];
  }
  async deleteFeeDiscount(id) {
    const result = await db.delete(feeDiscounts).where(eq(feeDiscounts.id, id)).returning({ id: feeDiscounts.id });
    return result.length > 0;
  }
};

// server/storage/index.ts
var storage = new DatabaseStorage();

// server/routes.ts
import { z as z2 } from "zod";
async function registerRoutes(app2) {
  const apiRouter = app2;
  apiRouter.get("/api/students", async (req, res) => {
    try {
      const { program, year, status, searchTerm } = req.query;
      let students2 = await storage.getStudents();
      if (program && program !== "all") {
        const programId = parseInt(program);
        if (!isNaN(programId)) {
          students2 = students2.filter((student) => student.programId === programId);
        }
      }
      if (year && year !== "all") {
        const yearLevel = parseInt(year);
        if (!isNaN(yearLevel)) {
          students2 = students2.filter((student) => student.yearLevel === yearLevel);
        }
      }
      if (status && status !== "all") {
        const statusLower = status.toLowerCase();
        students2 = students2.filter((student) => {
          const studentStatus = student.status?.toLowerCase() || "";
          if (statusLower === "active" || statusLower === "actief") {
            return studentStatus === "active" || studentStatus === "actief";
          } else if (statusLower === "pending" || statusLower === "in afwachting") {
            return studentStatus === "pending" || studentStatus === "in afwachting";
          } else if (statusLower === "inactive" || statusLower === "inactief") {
            return studentStatus === "inactive" || studentStatus === "inactief";
          }
          return studentStatus === statusLower;
        });
      }
      if (searchTerm) {
        const term = searchTerm.toLowerCase();
        students2 = students2.filter(
          (student) => (student.firstName?.toLowerCase() || "").includes(term) || (student.lastName?.toLowerCase() || "").includes(term) || (student.email?.toLowerCase() || "").includes(term) || (student.studentId?.toLowerCase() || "").includes(term)
        );
      }
      res.json(students2);
    } catch (error) {
      console.error("Error fetching students:", error);
      res.status(500).json({ message: "Error fetching students" });
    }
  });
  apiRouter.get("/api/students/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const student = await storage.getStudent(id);
      if (!student) {
        return res.status(404).json({ message: "Student not found" });
      }
      res.json(student);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student" });
    }
  });
  async function generateNextStudentId() {
    try {
      const allStudents = await storage.getStudents();
      if (!allStudents || allStudents.length === 0) {
        return "ST001";
      }
      const validNums = allStudents.map((student) => student.studentId).filter((id) => /^ST\d+$/.test(id)).map((id) => parseInt(id.substring(2), 10)).filter((num) => !isNaN(num)).sort((a, b) => a - b);
      if (validNums.length === 0) {
        return "ST001";
      }
      let expectedNum = 1;
      for (const num of validNums) {
        if (num > expectedNum) {
          return `ST${expectedNum.toString().padStart(3, "0")}`;
        }
        expectedNum = num + 1;
      }
      return `ST${expectedNum.toString().padStart(3, "0")}`;
    } catch (error) {
      console.error("Fout bij genereren studentnummer:", error);
      return `ST${Math.floor(Math.random() * 999 + 1).toString().padStart(3, "0")}`;
    }
  }
  apiRouter.get("/api/next-student-id", async (req, res) => {
    try {
      const nextStudentId = await generateNextStudentId();
      res.json({ nextStudentId });
    } catch (error) {
      console.error("Fout bij ophalen volgend studentnummer:", error);
      res.status(500).json({
        message: "Fout bij ophalen volgend studentnummer",
        nextStudentId: null
      });
    }
  });
  async function generateNextTeacherId() {
    try {
      const allTeachers = await storage.getTeachers();
      if (!allTeachers || allTeachers.length === 0) {
        return "D001";
      }
      const validIds = allTeachers.map((teacher) => teacher.teacherId).filter((id) => /^D\d{3}$/.test(id)).map((id) => parseInt(id.substring(1), 10)).filter((id) => !isNaN(id)).sort((a, b) => a - b);
      if (validIds.length === 0) {
        return "D001";
      }
      let expectedId = 1;
      for (const id of validIds) {
        if (id > expectedId) {
          return `D${expectedId.toString().padStart(3, "0")}`;
        }
        expectedId = id + 1;
      }
      return `D${expectedId.toString().padStart(3, "0")}`;
    } catch (error) {
      console.error("Fout bij genereren docentnummer:", error);
      const randomNum = Math.floor(Math.random() * 999 + 1);
      return `D${randomNum.toString().padStart(3, "0")}`;
    }
  }
  apiRouter.get("/api/next-teacher-id", async (req, res) => {
    try {
      const nextTeacherId = await generateNextTeacherId();
      res.json({ nextTeacherId });
    } catch (error) {
      console.error("Fout bij ophalen volgend docentnummer:", error);
      res.status(500).json({
        message: "Fout bij ophalen volgend docentnummer",
        nextTeacherId: null
      });
    }
  });
  apiRouter.post("/api/students", async (req, res) => {
    try {
      console.log("Received student data:", req.body);
      const studentData = { ...req.body };
      studentData.studentId = await generateNextStudentId();
      console.log("Gegenereerd studentnummer:", studentData.studentId);
      const validatedData = insertStudentSchema.parse(studentData);
      console.log("Validated student data:", validatedData);
      const newStudent = await storage.createStudent(validatedData);
      try {
        const currentDate = /* @__PURE__ */ new Date();
        const currentYear = currentDate.getFullYear();
        const academicYear = `${currentYear}-${currentYear + 1}`;
        const invoiceNumber = `INV-${currentYear}-${newStudent.id.toString().padStart(4, "0")}`;
        const defaultTuition = 1250;
        const feeRecord = {
          studentId: newStudent.id,
          invoiceNumber,
          description: `Collegegeld ${academicYear}`,
          amount: defaultTuition,
          dueDate: new Date(currentYear, 8, 30),
          // 30 september van het huidige jaar
          status: "niet betaald",
          // nog niet betaald
          academicYear,
          semester: "volledig jaar",
          createdAt: /* @__PURE__ */ new Date()
        };
        const newFee = await storage.createFee(feeRecord);
        console.log("Collegegeldrecord aangemaakt:", newFee);
        res.status(201).json({
          ...newStudent,
          feeCreated: true,
          feeDetails: {
            id: newFee.id,
            invoiceNumber: newFee.invoiceNumber,
            amount: newFee.amount,
            dueDate: newFee.dueDate
          }
        });
      } catch (feeError) {
        console.error("Fout bij aanmaken collegegeldrecord:", feeError);
        res.status(201).json({
          ...newStudent,
          feeCreated: false,
          feeError: "Kon geen collegegeldrecord aanmaken"
        });
      }
    } catch (error) {
      if (error instanceof z2.ZodError) {
        console.error("Student validation error:", error.errors);
        return res.status(400).json({
          message: "Validation error",
          errors: error.errors,
          received: req.body
          // Dit helpt bij diagnose
        });
      }
      if (error.code === "23505") {
        const fieldName = error.constraint?.includes("student_id") ? "studentnummer" : error.constraint?.includes("email") ? "e-mailadres" : "veld";
        console.error(`Duplicate key error for ${fieldName}:`, error);
        return res.status(409).json({
          message: `Er bestaat al een student met dit ${fieldName}. Kies een andere waarde.`,
          field: error.constraint,
          detail: error.detail
        });
      }
      console.error("Error creating student:", error);
      res.status(500).json({
        message: "Fout bij het aanmaken van de student",
        detail: error.message || "Onbekende fout"
      });
    }
  });
  apiRouter.put("/api/students/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Ongeldig ID formaat" });
      }
      const existingStudent = await storage.getStudent(id);
      if (!existingStudent) {
        return res.status(404).json({ message: "Student niet gevonden" });
      }
      console.log("Received student update data:", req.body);
      const updatedData = { ...req.body };
      if (updatedData.studentId) {
        console.log(`Poging tot wijzigen studentnummer gedetecteerd. Origineel: ${existingStudent.studentId}, Nieuw: ${updatedData.studentId}`);
        delete updatedData.studentId;
      }
      const validatedData = insertStudentSchema.partial().parse(updatedData);
      console.log("Validated student update data:", validatedData);
      const updatedStudent = await storage.updateStudent(id, validatedData);
      if (!updatedStudent) {
        return res.status(404).json({ message: "Student niet gevonden" });
      }
      res.json(updatedStudent);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        console.error("Student update validation error:", error.errors);
        return res.status(400).json({
          message: "Validatiefout",
          errors: error.errors,
          received: req.body
          // Dit helpt bij diagnose
        });
      }
      if (error.code === "23505") {
        const fieldName = error.constraint?.includes("student_id") ? "studentnummer" : error.constraint?.includes("email") ? "e-mailadres" : "veld";
        console.error(`Duplicate key error for ${fieldName}:`, error);
        return res.status(409).json({
          message: `Er bestaat al een student met dit ${fieldName}. Kies een andere waarde.`,
          field: error.constraint,
          detail: error.detail
        });
      }
      console.error("Update student error:", error);
      res.status(500).json({
        message: "Fout bij het bijwerken van de student",
        detail: error.message || "Onbekende fout"
      });
    }
  });
  apiRouter.delete("/api/students/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteStudent(id);
      if (!success) {
        return res.status(404).json({ message: "Student not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting student" });
    }
  });
  apiRouter.get("/api/programs", async (_req, res) => {
    try {
      const programs2 = await storage.getPrograms();
      res.json(programs2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching programs" });
    }
  });
  apiRouter.get("/api/programs/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const program = await storage.getProgram(id);
      if (!program) {
        return res.status(404).json({ message: "Program not found" });
      }
      res.json(program);
    } catch (error) {
      res.status(500).json({ message: "Error fetching program" });
    }
  });
  apiRouter.post("/api/programs", async (req, res) => {
    try {
      const validatedData = insertProgramSchema.parse(req.body);
      const newProgram = await storage.createProgram(validatedData);
      res.status(201).json(newProgram);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating program" });
    }
  });
  apiRouter.put("/api/programs/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedProgram = await storage.updateProgram(id, req.body);
      if (!updatedProgram) {
        return res.status(404).json({ message: "Program not found" });
      }
      res.json(updatedProgram);
    } catch (error) {
      res.status(500).json({ message: "Error updating program" });
    }
  });
  apiRouter.delete("/api/programs/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteProgram(id);
      if (!success) {
        return res.status(404).json({ message: "Program not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting program" });
    }
  });
  apiRouter.get("/api/courses", async (req, res) => {
    try {
      const isActive = req.query.isActive;
      let courses2;
      if (isActive !== void 0) {
        const activeFilter = isActive === "true";
        courses2 = await storage.getCoursesByFilter({ isActive: activeFilter });
      } else {
        courses2 = await storage.getCourses();
      }
      res.json({ courses: courses2, totalCount: courses2.length });
    } catch (error) {
      console.error("Error fetching courses:", error);
      res.status(500).json({ message: "Error fetching courses" });
    }
  });
  apiRouter.get("/api/dashboard/active-courses", async (_req, res) => {
    try {
      const courses2 = await storage.getCoursesByFilter({ isActive: true });
      res.json(courses2);
    } catch (error) {
      console.error("Error fetching active courses:", error);
      res.status(500).json({ message: "Error fetching active courses" });
    }
  });
  apiRouter.get("/api/teacher-course-assignments/:teacherId", async (req, res) => {
    try {
      const teacherId = parseInt(req.params.teacherId);
      if (isNaN(teacherId)) {
        return res.status(400).json({ message: "Invalid teacher ID format" });
      }
      const assignments = await storage.getTeacherCourseAssignmentsByTeacher(teacherId);
      res.json(assignments);
    } catch (error) {
      console.error("Error fetching teacher course assignments:", error);
      res.status(500).json({ message: "Error fetching teacher course assignments" });
    }
  });
  apiRouter.get("/api/teacher-course-assignments", async (_req, res) => {
    try {
      const assignments = await storage.getTeacherCourseAssignments();
      res.json(assignments);
    } catch (error) {
      console.error("Error fetching all teacher course assignments:", error);
      res.status(500).json({ message: "Error fetching all teacher course assignments" });
    }
  });
  apiRouter.post("/api/teachers/:teacherId/course-assignments", async (req, res) => {
    try {
      const teacherId = parseInt(req.params.teacherId);
      if (isNaN(teacherId)) {
        return res.status(400).json({ message: "Invalid teacher ID format" });
      }
      const teacher = await storage.getTeacher(teacherId);
      if (!teacher) {
        return res.status(404).json({ message: "Teacher not found" });
      }
      const { assignments } = req.body;
      if (!assignments || !Array.isArray(assignments)) {
        return res.status(400).json({ message: "Invalid assignments data format" });
      }
      const currentAssignments = await storage.getTeacherCourseAssignmentsByTeacher(teacherId);
      for (const assignment of currentAssignments) {
        await storage.deleteTeacherCourseAssignment(assignment.id);
      }
      const results = [];
      for (const assignment of assignments) {
        const assignmentData = {
          teacherId,
          courseId: assignment.courseId,
          isPrimary: assignment.isPrimary || false,
          notes: assignment.notes || "",
          startDate: new Date(assignment.startDate || /* @__PURE__ */ new Date()),
          endDate: new Date(assignment.endDate || new Date((/* @__PURE__ */ new Date()).setFullYear((/* @__PURE__ */ new Date()).getFullYear() + 1)))
        };
        const result = await storage.createTeacherCourseAssignment(assignmentData);
        results.push(result);
      }
      res.status(200).json({ message: "Teacher course assignments updated", assignments: results });
    } catch (error) {
      console.error("Error updating teacher course assignments:", error);
      res.status(500).json({ message: "Error updating teacher course assignments" });
    }
  });
  apiRouter.get("/api/courses/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const course = await storage.getCourse(id);
      if (!course) {
        return res.status(404).json({ message: "Course not found" });
      }
      res.json(course);
    } catch (error) {
      res.status(500).json({ message: "Error fetching course" });
    }
  });
  apiRouter.get("/api/programs/:programId/courses", async (req, res) => {
    try {
      const programId = parseInt(req.params.programId);
      if (isNaN(programId)) {
        return res.status(400).json({ message: "Invalid program ID format" });
      }
      const courses2 = await storage.getCoursesByProgram(programId);
      res.json(courses2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching courses by program" });
    }
  });
  apiRouter.post("/api/courses", async (req, res) => {
    try {
      const validatedData = insertCourseSchema.parse(req.body);
      const newCourse = await storage.createCourse(validatedData);
      res.status(201).json(newCourse);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating course" });
    }
  });
  apiRouter.put("/api/courses/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedCourse = await storage.updateCourse(id, req.body);
      if (!updatedCourse) {
        return res.status(404).json({ message: "Course not found" });
      }
      res.json(updatedCourse);
    } catch (error) {
      res.status(500).json({ message: "Error updating course" });
    }
  });
  apiRouter.delete("/api/courses/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteCourse(id);
      if (!success) {
        return res.status(404).json({ message: "Course not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting course" });
    }
  });
  apiRouter.get("/api/enrollments", async (_req, res) => {
    try {
      const enrollments2 = await storage.getEnrollments();
      res.json(enrollments2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching enrollments" });
    }
  });
  apiRouter.get("/api/enrollments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const enrollment = await storage.getEnrollment(id);
      if (!enrollment) {
        return res.status(404).json({ message: "Enrollment not found" });
      }
      res.json(enrollment);
    } catch (error) {
      res.status(500).json({ message: "Error fetching enrollment" });
    }
  });
  apiRouter.get("/api/students/:studentId/enrollments", async (req, res) => {
    try {
      const studentId = parseInt(req.params.studentId);
      if (isNaN(studentId)) {
        return res.status(400).json({ message: "Invalid student ID format" });
      }
      const enrollments2 = await storage.getEnrollmentsByStudent(studentId);
      res.json(enrollments2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching enrollments by student" });
    }
  });
  apiRouter.get("/api/courses/:courseId/enrollments", async (req, res) => {
    try {
      const courseId = parseInt(req.params.courseId);
      if (isNaN(courseId)) {
        return res.status(400).json({ message: "Invalid course ID format" });
      }
      const enrollments2 = await storage.getEnrollmentsByCourse(courseId);
      res.json(enrollments2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching enrollments by course" });
    }
  });
  apiRouter.post("/api/enrollments", async (req, res) => {
    try {
      const validatedData = insertEnrollmentSchema.parse(req.body);
      const newEnrollment = await storage.createEnrollment(validatedData);
      res.status(201).json(newEnrollment);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating enrollment" });
    }
  });
  apiRouter.put("/api/enrollments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedEnrollment = await storage.updateEnrollment(id, req.body);
      if (!updatedEnrollment) {
        return res.status(404).json({ message: "Enrollment not found" });
      }
      res.json(updatedEnrollment);
    } catch (error) {
      res.status(500).json({ message: "Error updating enrollment" });
    }
  });
  apiRouter.delete("/api/enrollments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteEnrollment(id);
      if (!success) {
        return res.status(404).json({ message: "Enrollment not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting enrollment" });
    }
  });
  apiRouter.get("/api/attendance", async (_req, res) => {
    try {
      const attendanceRecords = await storage.getAttendanceRecords();
      res.json(attendanceRecords);
    } catch (error) {
      res.status(500).json({ message: "Error fetching attendance records" });
    }
  });
  apiRouter.get("/api/attendance/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const attendanceRecord = await storage.getAttendanceRecord(id);
      if (!attendanceRecord) {
        return res.status(404).json({ message: "Attendance record not found" });
      }
      res.json(attendanceRecord);
    } catch (error) {
      res.status(500).json({ message: "Error fetching attendance record" });
    }
  });
  apiRouter.get("/api/students/:studentId/attendance", async (req, res) => {
    try {
      const studentId = parseInt(req.params.studentId);
      if (isNaN(studentId)) {
        return res.status(400).json({ message: "Invalid student ID format" });
      }
      const attendanceRecords = await storage.getAttendanceByStudent(studentId);
      res.json(attendanceRecords);
    } catch (error) {
      res.status(500).json({ message: "Error fetching attendance records by student" });
    }
  });
  apiRouter.get("/api/courses/:courseId/attendance", async (req, res) => {
    try {
      const courseId = parseInt(req.params.courseId);
      if (isNaN(courseId)) {
        return res.status(400).json({ message: "Invalid course ID format" });
      }
      const attendanceRecords = await storage.getAttendanceByCourse(courseId);
      res.json(attendanceRecords);
    } catch (error) {
      res.status(500).json({ message: "Error fetching attendance records by course" });
    }
  });
  apiRouter.get("/api/attendance/date/:date", async (req, res) => {
    try {
      const date2 = new Date(req.params.date);
      if (isNaN(date2.getTime())) {
        return res.status(400).json({ message: "Invalid date format" });
      }
      const attendanceRecords = await storage.getAttendanceByDate(date2);
      res.json(attendanceRecords);
    } catch (error) {
      res.status(500).json({ message: "Error fetching attendance records by date" });
    }
  });
  apiRouter.post("/api/attendance", async (req, res) => {
    try {
      const validatedData = insertAttendanceSchema.parse(req.body);
      const newAttendanceRecord = await storage.createAttendance(validatedData);
      res.status(201).json(newAttendanceRecord);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating attendance record" });
    }
  });
  apiRouter.put("/api/attendance/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedAttendanceRecord = await storage.updateAttendance(id, req.body);
      if (!updatedAttendanceRecord) {
        return res.status(404).json({ message: "Attendance record not found" });
      }
      res.json(updatedAttendanceRecord);
    } catch (error) {
      res.status(500).json({ message: "Error updating attendance record" });
    }
  });
  apiRouter.delete("/api/attendance/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteAttendance(id);
      if (!success) {
        return res.status(404).json({ message: "Attendance record not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting attendance record" });
    }
  });
  apiRouter.get("/api/teacher-attendance", async (_req, res) => {
    try {
      const attendanceRecords = await storage.getTeacherAttendanceRecords();
      res.json(attendanceRecords);
    } catch (error) {
      console.error("Error fetching teacher attendance records:", error);
      res.status(500).json({ message: "Error fetching teacher attendance records" });
    }
  });
  apiRouter.get("/api/teacher-attendance/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const attendanceRecord = await storage.getTeacherAttendanceRecord(id);
      if (!attendanceRecord) {
        return res.status(404).json({ message: "Teacher attendance record not found" });
      }
      res.json(attendanceRecord);
    } catch (error) {
      console.error("Error fetching teacher attendance record:", error);
      res.status(500).json({ message: "Error fetching teacher attendance record" });
    }
  });
  apiRouter.get("/api/teachers/:teacherId/attendance", async (req, res) => {
    try {
      const teacherId = parseInt(req.params.teacherId);
      if (isNaN(teacherId)) {
        return res.status(400).json({ message: "Invalid teacher ID format" });
      }
      const attendanceRecords = await storage.getTeacherAttendanceByTeacher(teacherId);
      res.json(attendanceRecords);
    } catch (error) {
      console.error("Error fetching teacher attendance records by teacher:", error);
      res.status(500).json({ message: "Error fetching teacher attendance records by teacher" });
    }
  });
  apiRouter.get("/api/courses/:courseId/teacher-attendance", async (req, res) => {
    try {
      const courseId = parseInt(req.params.courseId);
      if (isNaN(courseId)) {
        return res.status(400).json({ message: "Invalid course ID format" });
      }
      const attendanceRecords = await storage.getTeacherAttendanceByCourse(courseId);
      res.json(attendanceRecords);
    } catch (error) {
      console.error("Error fetching teacher attendance records by course:", error);
      res.status(500).json({ message: "Error fetching teacher attendance records by course" });
    }
  });
  apiRouter.get("/api/teacher-attendance/date/:date", async (req, res) => {
    try {
      const date2 = new Date(req.params.date);
      if (isNaN(date2.getTime())) {
        return res.status(400).json({ message: "Invalid date format" });
      }
      const attendanceRecords = await storage.getTeacherAttendanceByDate(date2);
      res.json(attendanceRecords);
    } catch (error) {
      console.error("Error fetching teacher attendance records by date:", error);
      res.status(500).json({ message: "Error fetching teacher attendance records by date" });
    }
  });
  apiRouter.post("/api/teacher-attendance", async (req, res) => {
    try {
      const validatedData = insertTeacherAttendanceSchema.parse(req.body);
      const newAttendanceRecord = await storage.createTeacherAttendance(validatedData);
      res.status(201).json(newAttendanceRecord);
    } catch (error) {
      console.error("Error creating teacher attendance record:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating teacher attendance record" });
    }
  });
  apiRouter.put("/api/teacher-attendance/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const existingRecord = await storage.getTeacherAttendanceRecord(id);
      if (!existingRecord) {
        return res.status(404).json({ message: "Teacher attendance record not found" });
      }
      const validatedData = insertTeacherAttendanceSchema.partial().parse(req.body);
      const updatedAttendanceRecord = await storage.updateTeacherAttendance(id, validatedData);
      if (!updatedAttendanceRecord) {
        return res.status(404).json({ message: "Teacher attendance record not found" });
      }
      res.json(updatedAttendanceRecord);
    } catch (error) {
      console.error("Error updating teacher attendance record:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error updating teacher attendance record" });
    }
  });
  apiRouter.delete("/api/teacher-attendance/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const existingRecord = await storage.getTeacherAttendanceRecord(id);
      if (!existingRecord) {
        return res.status(404).json({ message: "Teacher attendance record not found" });
      }
      const success = await storage.deleteTeacherAttendance(id);
      if (!success) {
        return res.status(404).json({ message: "Teacher attendance record not found" });
      }
      res.status(204).end();
    } catch (error) {
      console.error("Error deleting teacher attendance record:", error);
      res.status(500).json({ message: "Error deleting teacher attendance record" });
    }
  });
  apiRouter.get("/api/courses/:courseId/attendance/date/:date", async (req, res) => {
    try {
      const courseId = parseInt(req.params.courseId);
      const date2 = new Date(req.params.date);
      if (isNaN(courseId)) {
        return res.status(400).json({ message: "Invalid course ID format" });
      }
      if (isNaN(date2.getTime())) {
        return res.status(400).json({ message: "Invalid date format" });
      }
      const attendanceRecords = await storage.getAttendanceByClassAndDate(courseId, date2);
      res.json(attendanceRecords);
    } catch (error) {
      console.error("Error fetching attendance by class and date:", error);
      res.status(500).json({ message: "Error fetching attendance by class and date" });
    }
  });
  apiRouter.post("/api/attendance/batch", async (req, res) => {
    try {
      const attendanceRecords = req.body;
      if (!Array.isArray(attendanceRecords)) {
        return res.status(400).json({ message: "Expected an array of attendance records" });
      }
      const results = [];
      for (const record of attendanceRecords) {
        try {
          const validatedData = insertAttendanceSchema.parse(record);
          const newRecord = await storage.createAttendance(validatedData);
          results.push({ success: true, record: newRecord });
        } catch (error) {
          results.push({ success: false, error: error instanceof z2.ZodError ? error.errors : "Validation error", record });
        }
      }
      const success = results.every((r) => r.success);
      if (success) {
        res.status(201).json({ success: true, results });
      } else {
        res.status(207).json({ success: false, results });
      }
    } catch (error) {
      console.error("Error processing batch attendance records:", error);
      res.status(500).json({ message: "Error processing batch attendance records" });
    }
  });
  apiRouter.get("/api/assessments", async (_req, res) => {
    try {
      const assessments2 = await storage.getAssessments();
      res.json(assessments2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching assessments" });
    }
  });
  apiRouter.get("/api/assessments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const assessment = await storage.getAssessment(id);
      if (!assessment) {
        return res.status(404).json({ message: "Assessment not found" });
      }
      res.json(assessment);
    } catch (error) {
      res.status(500).json({ message: "Error fetching assessment" });
    }
  });
  apiRouter.get("/api/courses/:courseId/assessments", async (req, res) => {
    try {
      const courseId = parseInt(req.params.courseId);
      if (isNaN(courseId)) {
        return res.status(400).json({ message: "Invalid course ID format" });
      }
      const assessments2 = await storage.getAssessmentsByCourse(courseId);
      res.json(assessments2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching assessments by course" });
    }
  });
  apiRouter.post("/api/assessments", async (req, res) => {
    try {
      const validatedData = insertAssessmentSchema.parse(req.body);
      const newAssessment = await storage.createAssessment(validatedData);
      res.status(201).json(newAssessment);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating assessment" });
    }
  });
  apiRouter.put("/api/assessments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedAssessment = await storage.updateAssessment(id, req.body);
      if (!updatedAssessment) {
        return res.status(404).json({ message: "Assessment not found" });
      }
      res.json(updatedAssessment);
    } catch (error) {
      res.status(500).json({ message: "Error updating assessment" });
    }
  });
  apiRouter.delete("/api/assessments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteAssessment(id);
      if (!success) {
        return res.status(404).json({ message: "Assessment not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting assessment" });
    }
  });
  apiRouter.get("/api/grades", async (_req, res) => {
    try {
      const grades2 = await storage.getGrades();
      res.json(grades2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching grades" });
    }
  });
  apiRouter.get("/api/grades/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const grade = await storage.getGrade(id);
      if (!grade) {
        return res.status(404).json({ message: "Grade not found" });
      }
      res.json(grade);
    } catch (error) {
      res.status(500).json({ message: "Error fetching grade" });
    }
  });
  apiRouter.get("/api/students/:studentId/grades", async (req, res) => {
    try {
      const studentId = parseInt(req.params.studentId);
      if (isNaN(studentId)) {
        return res.status(400).json({ message: "Invalid student ID format" });
      }
      const grades2 = await storage.getGradesByStudent(studentId);
      res.json(grades2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching grades by student" });
    }
  });
  apiRouter.get("/api/courses/:courseId/grades", async (req, res) => {
    try {
      const courseId = parseInt(req.params.courseId);
      if (isNaN(courseId)) {
        return res.status(400).json({ message: "Invalid course ID format" });
      }
      const grades2 = await storage.getGradesByCourse(courseId);
      res.json(grades2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching grades by course" });
    }
  });
  apiRouter.get("/api/students/:studentId/courses/:courseId/grades", async (req, res) => {
    try {
      const studentId = parseInt(req.params.studentId);
      const courseId = parseInt(req.params.courseId);
      if (isNaN(studentId) || isNaN(courseId)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const grades2 = await storage.getGradesByStudentAndCourse(studentId, courseId);
      res.json(grades2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching grades by student and course" });
    }
  });
  apiRouter.post("/api/grades", async (req, res) => {
    try {
      const validatedData = insertGradeSchema.parse(req.body);
      const newGrade = await storage.createGrade(validatedData);
      res.status(201).json(newGrade);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating grade" });
    }
  });
  apiRouter.post("/api/grades/batch", async (req, res) => {
    try {
      const grades2 = req.body.grades;
      if (!Array.isArray(grades2)) {
        return res.status(400).json({ message: "Grades must be an array" });
      }
      const validatedGrades = grades2.map((grade) => insertGradeSchema.parse(grade));
      const newGrades = await storage.batchCreateGrades(validatedGrades);
      res.status(201).json(newGrades);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating grades" });
    }
  });
  apiRouter.put("/api/grades/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedGrade = await storage.updateGrade(id, req.body);
      if (!updatedGrade) {
        return res.status(404).json({ message: "Grade not found" });
      }
      res.json(updatedGrade);
    } catch (error) {
      res.status(500).json({ message: "Error updating grade" });
    }
  });
  apiRouter.delete("/api/grades/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteGrade(id);
      if (!success) {
        return res.status(404).json({ message: "Grade not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting grade" });
    }
  });
  apiRouter.get("/api/behavior-assessments", async (req, res) => {
    try {
      const { studentId, classId } = req.query;
      let filter = {};
      if (studentId) filter = { ...filter, studentId: parseInt(studentId) };
      if (classId) filter = { ...filter, classId: parseInt(classId) };
      const assessments2 = await storage.getBehaviorAssessments(filter);
      res.json(assessments2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching behavior assessments" });
    }
  });
  apiRouter.get("/api/behavior-assessments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const assessment = await storage.getBehaviorAssessment(id);
      if (!assessment) {
        return res.status(404).json({ message: "Behavior assessment not found" });
      }
      res.json(assessment);
    } catch (error) {
      res.status(500).json({ message: "Error fetching behavior assessment" });
    }
  });
  apiRouter.post("/api/behavior-assessments", async (req, res) => {
    try {
      const validatedData = insertBehaviorAssessmentSchema.parse(req.body);
      const newAssessment = await storage.createBehaviorAssessment(validatedData);
      res.status(201).json(newAssessment);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating behavior assessment" });
    }
  });
  apiRouter.post("/api/behavior-assessments/batch", async (req, res) => {
    try {
      if (!Array.isArray(req.body)) {
        return res.status(400).json({ message: "Expected an array of behavior assessments" });
      }
      const validatedAssessments = req.body.map(
        (assessment) => insertBehaviorAssessmentSchema.parse(assessment)
      );
      const newAssessments = await storage.createBehaviorAssessments(validatedAssessments);
      res.status(201).json(newAssessments);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating behavior assessments" });
    }
  });
  apiRouter.put("/api/behavior-assessments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedAssessment = await storage.updateBehaviorAssessment(id, req.body);
      if (!updatedAssessment) {
        return res.status(404).json({ message: "Behavior assessment not found" });
      }
      res.json(updatedAssessment);
    } catch (error) {
      res.status(500).json({ message: "Error updating behavior assessment" });
    }
  });
  apiRouter.delete("/api/behavior-assessments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteBehaviorAssessment(id);
      if (!success) {
        return res.status(404).json({ message: "Behavior assessment not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting behavior assessment" });
    }
  });
  apiRouter.get("/api/events", async (_req, res) => {
    try {
      const events2 = await storage.getEvents();
      res.json(events2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching events" });
    }
  });
  apiRouter.get("/api/events/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const event = await storage.getEvent(id);
      if (!event) {
        return res.status(404).json({ message: "Event not found" });
      }
      res.json(event);
    } catch (error) {
      res.status(500).json({ message: "Error fetching event" });
    }
  });
  apiRouter.get("/api/events/range", async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      if (!startDate || !endDate) {
        return res.status(400).json({ message: "Start date and end date are required" });
      }
      const start = new Date(startDate);
      const end = new Date(endDate);
      if (isNaN(start.getTime()) || isNaN(end.getTime())) {
        return res.status(400).json({ message: "Invalid date format" });
      }
      const events2 = await storage.getEventsByDateRange(start, end);
      res.json(events2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching events by date range" });
    }
  });
  apiRouter.post("/api/events", async (req, res) => {
    try {
      const validatedData = insertEventSchema.parse(req.body);
      const newEvent = await storage.createEvent(validatedData);
      res.status(201).json(newEvent);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating event" });
    }
  });
  apiRouter.put("/api/events/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedEvent = await storage.updateEvent(id, req.body);
      if (!updatedEvent) {
        return res.status(404).json({ message: "Event not found" });
      }
      res.json(updatedEvent);
    } catch (error) {
      res.status(500).json({ message: "Error updating event" });
    }
  });
  apiRouter.delete("/api/events/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteEvent(id);
      if (!success) {
        return res.status(404).json({ message: "Event not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting event" });
    }
  });
  apiRouter.get("/api/fees/stats", async (_req, res) => {
    try {
      const stats = await storage.getFeeStats();
      if (!stats) {
        return res.status(404).json({ message: "Fee stats not available" });
      }
      res.json({ stats });
    } catch (error) {
      console.error("Error fetching fee stats:", error);
      res.status(500).json({ message: "Error fetching fee statistics" });
    }
  });
  apiRouter.get("/api/fees/outstanding", async (_req, res) => {
    try {
      const outstandingDebts = await storage.getOutstandingDebts();
      res.json(outstandingDebts);
    } catch (error) {
      console.error("Error fetching outstanding debts:", error);
      res.status(500).json({ message: "Error fetching outstanding debts" });
    }
  });
  apiRouter.get("/api/fees", async (_req, res) => {
    try {
      const fees2 = await storage.getFees();
      res.json(fees2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching fees" });
    }
  });
  apiRouter.get("/api/fees/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const fee = await storage.getFee(id);
      if (!fee) {
        return res.status(404).json({ message: "Fee not found" });
      }
      res.json(fee);
    } catch (error) {
      res.status(500).json({ message: "Error fetching fee" });
    }
  });
  apiRouter.get("/api/students/:studentId/fees", async (req, res) => {
    try {
      const studentId = parseInt(req.params.studentId);
      if (isNaN(studentId)) {
        return res.status(400).json({ message: "Invalid student ID format" });
      }
      const fees2 = await storage.getFeesByStudent(studentId);
      res.json(fees2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching fees by student" });
    }
  });
  apiRouter.get("/api/fees/status/:status", async (req, res) => {
    try {
      const status = req.params.status;
      const fees2 = await storage.getFeesByStatus(status);
      res.json(fees2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching fees by status" });
    }
  });
  apiRouter.get("/api/fees/range", async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      if (!startDate || !endDate) {
        return res.status(400).json({ message: "Start date and end date are required" });
      }
      const start = new Date(startDate);
      const end = new Date(endDate);
      if (isNaN(start.getTime()) || isNaN(end.getTime())) {
        return res.status(400).json({ message: "Invalid date format" });
      }
      const fees2 = await storage.getFeesByDateRange(start, end);
      res.json(fees2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching fees by date range" });
    }
  });
  apiRouter.post("/api/fees", async (req, res) => {
    try {
      const validatedData = insertFeeSchema.parse(req.body);
      const newFee = await storage.createFee(validatedData);
      res.status(201).json(newFee);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating fee" });
    }
  });
  apiRouter.put("/api/fees/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedFee = await storage.updateFee(id, req.body);
      if (!updatedFee) {
        return res.status(404).json({ message: "Fee not found" });
      }
      res.json(updatedFee);
    } catch (error) {
      res.status(500).json({ message: "Error updating fee" });
    }
  });
  apiRouter.delete("/api/fees/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteFee(id);
      if (!success) {
        return res.status(404).json({ message: "Fee not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting fee" });
    }
  });
  apiRouter.get("/api/fee-settings", async (_req, res) => {
    try {
      const settings = await storage.getFeeSettings();
      res.json(settings);
    } catch (error) {
      console.error("Error fetching fee settings:", error);
      res.status(500).json({ message: "Error fetching fee settings" });
    }
  });
  apiRouter.get("/api/fee-settings/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const setting = await storage.getFeeSetting(id);
      if (!setting) {
        return res.status(404).json({ message: "Fee setting not found" });
      }
      res.json(setting);
    } catch (error) {
      console.error("Error fetching fee setting:", error);
      res.status(500).json({ message: "Error fetching fee setting" });
    }
  });
  apiRouter.get("/api/fee-settings/academic-year/:year", async (req, res) => {
    try {
      const year = req.params.year;
      const setting = await storage.getFeeSettingByAcademicYear(year);
      if (!setting) {
        return res.status(404).json({ message: "Fee setting not found for academic year" });
      }
      res.json(setting);
    } catch (error) {
      console.error("Error fetching fee setting by academic year:", error);
      res.status(500).json({ message: "Error fetching fee setting by academic year" });
    }
  });
  apiRouter.post("/api/fee-settings", async (req, res) => {
    try {
      const newSetting = await storage.createFeeSetting(req.body);
      res.status(201).json(newSetting);
    } catch (error) {
      console.error("Error creating fee setting:", error);
      res.status(500).json({ message: "Error creating fee setting" });
    }
  });
  apiRouter.put("/api/fee-settings/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedSetting = await storage.updateFeeSetting(id, req.body);
      if (!updatedSetting) {
        return res.status(404).json({ message: "Fee setting not found" });
      }
      res.json(updatedSetting);
    } catch (error) {
      console.error("Error updating fee setting:", error);
      res.status(500).json({ message: "Error updating fee setting" });
    }
  });
  apiRouter.delete("/api/fee-settings/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteFeeSetting(id);
      if (!success) {
        return res.status(404).json({ message: "Fee setting not found" });
      }
      res.status(204).end();
    } catch (error) {
      console.error("Error deleting fee setting:", error);
      res.status(500).json({ message: "Error deleting fee setting" });
    }
  });
  apiRouter.get("/api/fee-discounts", async (_req, res) => {
    try {
      const discounts = await storage.getFeeDiscounts();
      res.json(discounts);
    } catch (error) {
      console.error("Error fetching fee discounts:", error);
      res.status(500).json({ message: "Error fetching fee discounts" });
    }
  });
  apiRouter.get("/api/fee-discounts/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const discount = await storage.getFeeDiscount(id);
      if (!discount) {
        return res.status(404).json({ message: "Fee discount not found" });
      }
      res.json(discount);
    } catch (error) {
      console.error("Error fetching fee discount:", error);
      res.status(500).json({ message: "Error fetching fee discount" });
    }
  });
  apiRouter.get("/api/fee-discounts/academic-year/:year", async (req, res) => {
    try {
      const year = req.params.year;
      const discounts = await storage.getFeeDiscountsByAcademicYear(year);
      res.json(discounts);
    } catch (error) {
      console.error("Error fetching fee discounts by academic year:", error);
      res.status(500).json({ message: "Error fetching fee discounts by academic year" });
    }
  });
  apiRouter.post("/api/fee-discounts", async (req, res) => {
    try {
      const newDiscount = await storage.createFeeDiscount(req.body);
      res.status(201).json(newDiscount);
    } catch (error) {
      console.error("Error creating fee discount:", error);
      res.status(500).json({ message: "Error creating fee discount" });
    }
  });
  apiRouter.put("/api/fee-discounts/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedDiscount = await storage.updateFeeDiscount(id, req.body);
      if (!updatedDiscount) {
        return res.status(404).json({ message: "Fee discount not found" });
      }
      res.json(updatedDiscount);
    } catch (error) {
      console.error("Error updating fee discount:", error);
      res.status(500).json({ message: "Error updating fee discount" });
    }
  });
  apiRouter.delete("/api/fee-discounts/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteFeeDiscount(id);
      if (!success) {
        return res.status(404).json({ message: "Fee discount not found" });
      }
      res.status(204).end();
    } catch (error) {
      console.error("Error deleting fee discount:", error);
      res.status(500).json({ message: "Error deleting fee discount" });
    }
  });
  apiRouter.get("/api/student-groups", async (_req, res) => {
    try {
      const groups = await storage.getStudentGroups();
      res.json(groups);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student groups" });
    }
  });
  apiRouter.get("/api/student-groups/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const group = await storage.getStudentGroup(id);
      if (!group) {
        return res.status(404).json({ message: "Student group not found" });
      }
      res.json(group);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student group" });
    }
  });
  apiRouter.get("/api/programs/:programId/student-groups", async (req, res) => {
    try {
      const programId = parseInt(req.params.programId);
      if (isNaN(programId)) {
        return res.status(400).json({ message: "Invalid program ID format" });
      }
      const groups = await storage.getStudentGroupsByProgram(programId);
      res.json(groups);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student groups by program" });
    }
  });
  apiRouter.get("/api/courses/:courseId/student-groups", async (req, res) => {
    try {
      const courseId = parseInt(req.params.courseId);
      if (isNaN(courseId)) {
        return res.status(400).json({ message: "Invalid course ID format" });
      }
      const groups = await storage.getStudentGroupsByCourse(courseId);
      res.json(groups);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student groups by course" });
    }
  });
  apiRouter.get("/api/student-groups/year/:academicYear", async (req, res) => {
    try {
      const academicYear = req.params.academicYear;
      const groups = await storage.getStudentGroupsByAcademicYear(academicYear);
      res.json(groups);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student groups by academic year" });
    }
  });
  apiRouter.post("/api/student-groups", async (req, res) => {
    try {
      const validatedData = insertStudentGroupSchema.parse(req.body);
      const newGroup = await storage.createStudentGroup(validatedData);
      res.status(201).json(newGroup);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating student group" });
    }
  });
  apiRouter.put("/api/student-groups/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedGroup = await storage.updateStudentGroup(id, req.body);
      if (!updatedGroup) {
        return res.status(404).json({ message: "Student group not found" });
      }
      res.json(updatedGroup);
    } catch (error) {
      res.status(500).json({ message: "Error updating student group" });
    }
  });
  apiRouter.delete("/api/student-groups/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteStudentGroup(id);
      if (!success) {
        return res.status(404).json({ message: "Student group not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting student group" });
    }
  });
  apiRouter.get("/api/student-group-enrollments", async (_req, res) => {
    try {
      const enrollments2 = await storage.getStudentGroupEnrollments();
      res.json(enrollments2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student group enrollments" });
    }
  });
  apiRouter.get("/api/student-group-enrollments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const enrollment = await storage.getStudentGroupEnrollment(id);
      if (!enrollment) {
        return res.status(404).json({ message: "Student group enrollment not found" });
      }
      res.json(enrollment);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student group enrollment" });
    }
  });
  apiRouter.get("/api/student-groups/:groupId/enrollments", async (req, res) => {
    try {
      const groupId = parseInt(req.params.groupId);
      if (isNaN(groupId)) {
        return res.status(400).json({ message: "Invalid group ID format" });
      }
      const enrollments2 = await storage.getStudentGroupEnrollmentsByGroup(groupId);
      res.json(enrollments2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student group enrollments by group" });
    }
  });
  apiRouter.get("/api/students/:studentId/group-enrollments", async (req, res) => {
    try {
      const studentId = parseInt(req.params.studentId);
      if (isNaN(studentId)) {
        return res.status(400).json({ message: "Invalid student ID format" });
      }
      const enrollments2 = await storage.getStudentGroupEnrollmentsByStudent(studentId);
      res.json(enrollments2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student group enrollments by student" });
    }
  });
  apiRouter.post("/api/student-group-enrollments", async (req, res) => {
    try {
      const validatedData = insertStudentGroupEnrollmentSchema.parse(req.body);
      const newEnrollment = await storage.createStudentGroupEnrollment(validatedData);
      res.status(201).json(newEnrollment);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating student group enrollment" });
    }
  });
  apiRouter.put("/api/student-group-enrollments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedEnrollment = await storage.updateStudentGroupEnrollment(id, req.body);
      if (!updatedEnrollment) {
        return res.status(404).json({ message: "Student group enrollment not found" });
      }
      res.json(updatedEnrollment);
    } catch (error) {
      res.status(500).json({ message: "Error updating student group enrollment" });
    }
  });
  apiRouter.delete("/api/student-group-enrollments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteStudentGroupEnrollment(id);
      if (!success) {
        return res.status(404).json({ message: "Student group enrollment not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting student group enrollment" });
    }
  });
  apiRouter.get("/api/lessons", async (_req, res) => {
    try {
      const lessons2 = await storage.getLessons();
      res.json(lessons2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching lessons" });
    }
  });
  apiRouter.get("/api/lessons/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const lesson = await storage.getLesson(id);
      if (!lesson) {
        return res.status(404).json({ message: "Lesson not found" });
      }
      res.json(lesson);
    } catch (error) {
      res.status(500).json({ message: "Error fetching lesson" });
    }
  });
  apiRouter.get("/api/courses/:courseId/lessons", async (req, res) => {
    try {
      const courseId = parseInt(req.params.courseId);
      if (isNaN(courseId)) {
        return res.status(400).json({ message: "Invalid course ID format" });
      }
      const lessons2 = await storage.getLessonsByCourse(courseId);
      res.json(lessons2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching lessons by course" });
    }
  });
  apiRouter.get("/api/student-groups/:groupId/lessons", async (req, res) => {
    try {
      const groupId = parseInt(req.params.groupId);
      if (isNaN(groupId)) {
        return res.status(400).json({ message: "Invalid group ID format" });
      }
      const lessons2 = await storage.getLessonsByGroup(groupId);
      res.json(lessons2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching lessons by group" });
    }
  });
  apiRouter.get("/api/lessons/range", async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      if (!startDate || !endDate) {
        return res.status(400).json({ message: "Start date and end date are required" });
      }
      const start = new Date(startDate);
      const end = new Date(endDate);
      if (isNaN(start.getTime()) || isNaN(end.getTime())) {
        return res.status(400).json({ message: "Invalid date format" });
      }
      const lessons2 = await storage.getLessonsByDateRange(start, end);
      res.json(lessons2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching lessons by date range" });
    }
  });
  apiRouter.post("/api/lessons", async (req, res) => {
    try {
      const validatedData = insertLessonSchema.parse(req.body);
      const newLesson = await storage.createLesson(validatedData);
      res.status(201).json(newLesson);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating lesson" });
    }
  });
  apiRouter.put("/api/lessons/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedLesson = await storage.updateLesson(id, req.body);
      if (!updatedLesson) {
        return res.status(404).json({ message: "Lesson not found" });
      }
      res.json(updatedLesson);
    } catch (error) {
      res.status(500).json({ message: "Error updating lesson" });
    }
  });
  apiRouter.delete("/api/lessons/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteLesson(id);
      if (!success) {
        return res.status(404).json({ message: "Lesson not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting lesson" });
    }
  });
  apiRouter.get("/api/examinations", async (_req, res) => {
    try {
      const examinations2 = await storage.getExaminations();
      res.json(examinations2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching examinations" });
    }
  });
  apiRouter.get("/api/examinations/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const examination = await storage.getExamination(id);
      if (!examination) {
        return res.status(404).json({ message: "Examination not found" });
      }
      res.json(examination);
    } catch (error) {
      res.status(500).json({ message: "Error fetching examination" });
    }
  });
  apiRouter.get("/api/courses/:courseId/examinations", async (req, res) => {
    try {
      const courseId = parseInt(req.params.courseId);
      if (isNaN(courseId)) {
        return res.status(400).json({ message: "Invalid course ID format" });
      }
      const examinations2 = await storage.getExaminationsByCourse(courseId);
      res.json(examinations2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching examinations by course" });
    }
  });
  apiRouter.get("/api/examinations/range", async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      if (!startDate || !endDate) {
        return res.status(400).json({ message: "Start date and end date are required" });
      }
      const start = new Date(startDate);
      const end = new Date(endDate);
      if (isNaN(start.getTime()) || isNaN(end.getTime())) {
        return res.status(400).json({ message: "Invalid date format" });
      }
      const examinations2 = await storage.getExaminationsByDateRange(start, end);
      res.json(examinations2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching examinations by date range" });
    }
  });
  apiRouter.post("/api/examinations", async (req, res) => {
    try {
      const validatedData = insertExaminationSchema.parse(req.body);
      const newExamination = await storage.createExamination(validatedData);
      res.status(201).json(newExamination);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating examination" });
    }
  });
  apiRouter.put("/api/examinations/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedExamination = await storage.updateExamination(id, req.body);
      if (!updatedExamination) {
        return res.status(404).json({ message: "Examination not found" });
      }
      res.json(updatedExamination);
    } catch (error) {
      res.status(500).json({ message: "Error updating examination" });
    }
  });
  apiRouter.delete("/api/examinations/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteExamination(id);
      if (!success) {
        return res.status(404).json({ message: "Examination not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting examination" });
    }
  });
  apiRouter.get("/api/guardians", async (_req, res) => {
    try {
      const guardians2 = await storage.getGuardians();
      res.json(guardians2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching guardians" });
    }
  });
  apiRouter.get("/api/guardians/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const guardian = await storage.getGuardian(id);
      if (!guardian) {
        return res.status(404).json({ message: "Guardian not found" });
      }
      res.json(guardian);
    } catch (error) {
      res.status(500).json({ message: "Error fetching guardian" });
    }
  });
  apiRouter.post("/api/guardians", async (req, res) => {
    try {
      const validatedData = insertGuardianSchema.parse(req.body);
      const newGuardian = await storage.createGuardian(validatedData);
      res.status(201).json(newGuardian);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating guardian" });
    }
  });
  apiRouter.put("/api/guardians/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedGuardian = await storage.updateGuardian(id, req.body);
      if (!updatedGuardian) {
        return res.status(404).json({ message: "Guardian not found" });
      }
      res.json(updatedGuardian);
    } catch (error) {
      res.status(500).json({ message: "Error updating guardian" });
    }
  });
  apiRouter.delete("/api/guardians/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteGuardian(id);
      if (!success) {
        return res.status(404).json({ message: "Guardian not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting guardian" });
    }
  });
  apiRouter.get("/api/student-guardians", async (_req, res) => {
    try {
      const relations2 = await storage.getStudentGuardians();
      res.json(relations2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student-guardian relations" });
    }
  });
  apiRouter.get("/api/student-guardians/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const relation = await storage.getStudentGuardian(id);
      if (!relation) {
        return res.status(404).json({ message: "Student-guardian relation not found" });
      }
      res.json(relation);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student-guardian relation" });
    }
  });
  apiRouter.get("/api/students/:studentId/guardians", async (req, res) => {
    try {
      const studentId = parseInt(req.params.studentId);
      if (isNaN(studentId)) {
        return res.status(400).json({ message: "Invalid student ID format" });
      }
      const relations2 = await storage.getStudentGuardiansByStudent(studentId);
      res.json(relations2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student-guardian relations by student" });
    }
  });
  apiRouter.get("/api/guardians/:guardianId/students", async (req, res) => {
    try {
      const guardianId = parseInt(req.params.guardianId);
      if (isNaN(guardianId)) {
        return res.status(400).json({ message: "Invalid guardian ID format" });
      }
      const relations2 = await storage.getStudentGuardiansByGuardian(guardianId);
      res.json(relations2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student-guardian relations by guardian" });
    }
  });
  apiRouter.post("/api/student-guardians", async (req, res) => {
    try {
      console.log("Student-Guardian data received:", req.body);
      const validatedData = insertStudentGuardianSchema.parse(req.body);
      console.log("Validated data:", validatedData);
      const newRelation = await storage.createStudentGuardian(validatedData);
      res.status(201).json(newRelation);
    } catch (error) {
      console.error("Error creating student-guardian relation:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating student-guardian relation" });
    }
  });
  apiRouter.put("/api/student-guardians/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedRelation = await storage.updateStudentGuardian(id, req.body);
      if (!updatedRelation) {
        return res.status(404).json({ message: "Student-guardian relation not found" });
      }
      res.json(updatedRelation);
    } catch (error) {
      res.status(500).json({ message: "Error updating student-guardian relation" });
    }
  });
  apiRouter.delete("/api/student-guardians/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteStudentGuardian(id);
      if (!success) {
        return res.status(404).json({ message: "Student-guardian relation not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting student-guardian relation" });
    }
  });
  apiRouter.get("/api/student-programs", async (_req, res) => {
    try {
      const studentPrograms2 = await storage.getStudentPrograms();
      res.json(studentPrograms2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student programs" });
    }
  });
  apiRouter.get("/api/student-programs/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const studentProgram = await storage.getStudentProgram(id);
      if (!studentProgram) {
        return res.status(404).json({ message: "Student program not found" });
      }
      res.json(studentProgram);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student program" });
    }
  });
  apiRouter.get("/api/students/:studentId/programs", async (req, res) => {
    try {
      const studentId = parseInt(req.params.studentId);
      if (isNaN(studentId)) {
        return res.status(400).json({ message: "Invalid student ID format" });
      }
      const studentPrograms2 = await storage.getStudentProgramsByStudent(studentId);
      res.json(studentPrograms2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student programs" });
    }
  });
  apiRouter.get("/api/programs/:programId/students", async (req, res) => {
    try {
      const programId = parseInt(req.params.programId);
      if (isNaN(programId)) {
        return res.status(400).json({ message: "Invalid program ID format" });
      }
      const studentPrograms2 = await storage.getStudentProgramsByProgram(programId);
      res.json(studentPrograms2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching student programs" });
    }
  });
  apiRouter.get("/api/students/:studentId/primary-program", async (req, res) => {
    try {
      const studentId = parseInt(req.params.studentId);
      if (isNaN(studentId)) {
        return res.status(400).json({ message: "Invalid student ID format" });
      }
      const primaryProgram = await storage.getPrimaryProgramByStudent(studentId);
      if (!primaryProgram) {
        return res.status(404).json({ message: "Primary program not found for student" });
      }
      res.json(primaryProgram);
    } catch (error) {
      res.status(500).json({ message: "Error fetching primary program" });
    }
  });
  apiRouter.post("/api/student-programs", async (req, res) => {
    try {
      const validatedData = insertStudentProgramSchema.parse(req.body);
      const studentProgram = await storage.createStudentProgram(validatedData);
      res.status(201).json(studentProgram);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({
          message: "Invalid input data",
          errors: error.errors
        });
      }
      res.status(500).json({ message: "Error creating student program" });
    }
  });
  apiRouter.patch("/api/student-programs/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const studentProgram = await storage.updateStudentProgram(id, req.body);
      if (!studentProgram) {
        return res.status(404).json({ message: "Student program not found" });
      }
      res.json(studentProgram);
    } catch (error) {
      res.status(500).json({ message: "Error updating student program" });
    }
  });
  apiRouter.delete("/api/student-programs/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteStudentProgram(id);
      if (!success) {
        return res.status(404).json({ message: "Student program not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting student program" });
    }
  });
  apiRouter.get("/api/users", async (_req, res) => {
    try {
      const users2 = await storage.getUsers();
      res.json(users2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching users" });
    }
  });
  apiRouter.get("/api/users/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const user = await storage.getUser(id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      res.json(user);
    } catch (error) {
      res.status(500).json({ message: "Error fetching user" });
    }
  });
  apiRouter.post("/api/users", async (req, res) => {
    try {
      const validatedData = insertUserSchema.parse(req.body);
      const newUser = await storage.createUser(validatedData);
      res.status(201).json(newUser);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating user" });
    }
  });
  apiRouter.put("/api/users/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const updatedUser = await storage.updateUser(id, req.body);
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      }
      res.json(updatedUser);
    } catch (error) {
      res.status(500).json({ message: "Error updating user" });
    }
  });
  apiRouter.delete("/api/users/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteUser(id);
      if (!success) {
        return res.status(404).json({ message: "User not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting user" });
    }
  });
  apiRouter.get("/api/dashboard/stats", async (_req, res) => {
    try {
      const students2 = await storage.getStudents();
      const courses2 = await storage.getCourses();
      const programs2 = await storage.getPrograms();
      const enrollments2 = await storage.getEnrollments();
      const totalStudents = students2.length;
      const activeCourses = courses2.length;
      const activePrograms = programs2.length;
      const totalEnrollments = enrollments2.length;
      res.json({
        totalStudents,
        activeCourses,
        activePrograms,
        totalEnrollments
      });
    } catch (error) {
      res.status(500).json({ message: "Error fetching dashboard stats" });
    }
  });
  apiRouter.get("/api/dashboard/enrollment", async (_req, res) => {
    try {
      const enrollmentTrend = [
        { month: "Jan", count: 12 },
        { month: "Feb", count: 15 },
        { month: "Mar", count: 21 },
        { month: "Apr", count: 18 },
        { month: "Mei", count: 24 },
        { month: "Jun", count: 22 },
        { month: "Jul", count: 16 },
        { month: "Aug", count: 14 },
        { month: "Sep", count: 30 },
        { month: "Okt", count: 26 },
        { month: "Nov", count: 19 },
        { month: "Dec", count: 10 }
      ];
      res.json({ enrollmentTrend });
    } catch (error) {
      res.status(500).json({ message: "Error fetching enrollment trend" });
    }
  });
  apiRouter.get("/api/dashboard/recent-students", async (_req, res) => {
    try {
      const students2 = await storage.getStudents();
      const recentStudents = students2.slice(0, 5);
      res.json(recentStudents);
    } catch (error) {
      res.status(500).json({ message: "Error fetching recent students" });
    }
  });
  apiRouter.get("/api/dashboard/events", async (_req, res) => {
    try {
      const now = /* @__PURE__ */ new Date();
      const oneMonthLater = /* @__PURE__ */ new Date();
      oneMonthLater.setMonth(oneMonthLater.getMonth() + 1);
      const events2 = await storage.getEventsByDateRange(now, oneMonthLater);
      res.json(events2);
    } catch (error) {
      res.status(500).json({ message: "Error fetching upcoming events" });
    }
  });
  apiRouter.get("/api/teachers", async (req, res) => {
    try {
      const { searchTerm, page = "1", limit = "10" } = req.query;
      const pageNumber = parseInt(page) || 1;
      const limitNumber = parseInt(limit) || 10;
      const offset = (pageNumber - 1) * limitNumber;
      let teachers2 = await storage.getTeachers();
      console.log("Fetched teachers:", teachers2);
      let totalCount = teachers2.length;
      if (searchTerm) {
        const term = searchTerm.toLowerCase();
        teachers2 = teachers2.filter(
          (teacher) => teacher.firstName.toLowerCase().includes(term) || teacher.lastName.toLowerCase().includes(term) || teacher.email.toLowerCase().includes(term)
        );
        totalCount = teachers2.length;
      }
      teachers2 = teachers2.slice(offset, offset + limitNumber);
      res.json({ teachers: teachers2, totalCount });
    } catch (error) {
      console.error("Error fetching teachers:", error);
      res.status(500).json({ message: "Error fetching teachers" });
    }
  });
  apiRouter.get("/api/teachers/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const teacher = await storage.getTeacher(id);
      if (!teacher) {
        return res.status(404).json({ message: "Teacher not found" });
      }
      res.json(teacher);
    } catch (error) {
      res.status(500).json({ message: "Error fetching teacher" });
    }
  });
  apiRouter.post("/api/teachers", async (req, res) => {
    try {
      const validatedData = insertTeacherSchema.parse(req.body);
      const existingTeacher = await storage.getTeacherByEmail(validatedData.email);
      if (existingTeacher) {
        return res.status(409).json({ message: "Email already in use" });
      }
      if (!validatedData.teacherId) {
        const teachers2 = await storage.getTeachers();
        const nextId = (teachers2.length + 1).toString();
        validatedData.teacherId = `D-${nextId.padStart(3, "0")}`;
      }
      const teacher = await storage.createTeacher(validatedData);
      res.status(201).json(teacher);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Invalid teacher data", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating teacher" });
    }
  });
  apiRouter.put("/api/teachers/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const existingTeacher = await storage.getTeacher(id);
      if (!existingTeacher) {
        return res.status(404).json({ message: "Teacher not found" });
      }
      const validatedData = insertTeacherSchema.partial().parse(req.body);
      if (validatedData.email && validatedData.email !== existingTeacher.email) {
        const teacherWithEmail = await storage.getTeacherByEmail(validatedData.email);
        if (teacherWithEmail && teacherWithEmail.id !== id) {
          return res.status(409).json({ message: "Email already in use by another teacher" });
        }
      }
      const updatedTeacher = await storage.updateTeacher(id, validatedData);
      res.json(updatedTeacher);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Invalid teacher data", errors: error.errors });
      }
      res.status(500).json({ message: "Error updating teacher" });
    }
  });
  apiRouter.delete("/api/teachers/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteTeacher(id);
      if (!success) {
        return res.status(404).json({ message: "Teacher not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting teacher" });
    }
  });
  apiRouter.get("/api/teacher-availability", async (req, res) => {
    try {
      const { teacherId } = req.query;
      if (teacherId) {
        const id = parseInt(teacherId);
        if (isNaN(id)) {
          return res.status(400).json({ message: "Invalid teacher ID format" });
        }
        const availabilities = await storage.getTeacherAvailabilitiesByTeacher(id);
        res.json(availabilities);
      } else {
        const availabilities = await storage.getTeacherAvailabilities();
        res.json(availabilities);
      }
    } catch (error) {
      res.status(500).json({ message: "Error fetching teacher availabilities" });
    }
  });
  apiRouter.get("/api/teacher-availability/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const availability = await storage.getTeacherAvailability(id);
      if (!availability) {
        return res.status(404).json({ message: "Teacher availability not found" });
      }
      res.json(availability);
    } catch (error) {
      res.status(500).json({ message: "Error fetching teacher availability" });
    }
  });
  apiRouter.post("/api/teacher-availability", async (req, res) => {
    try {
      const validatedData = insertTeacherAvailabilitySchema.parse(req.body);
      const teacher = await storage.getTeacher(validatedData.teacherId);
      if (!teacher) {
        return res.status(404).json({ message: "Teacher not found" });
      }
      const availability = await storage.createTeacherAvailability(validatedData);
      res.status(201).json(availability);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Invalid availability data", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating teacher availability" });
    }
  });
  apiRouter.put("/api/teacher-availability/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const existingAvailability = await storage.getTeacherAvailability(id);
      if (!existingAvailability) {
        return res.status(404).json({ message: "Teacher availability not found" });
      }
      const validatedData = insertTeacherAvailabilitySchema.partial().parse(req.body);
      const updatedAvailability = await storage.updateTeacherAvailability(id, validatedData);
      res.json(updatedAvailability);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Invalid availability data", errors: error.errors });
      }
      res.status(500).json({ message: "Error updating teacher availability" });
    }
  });
  apiRouter.delete("/api/teacher-availability/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteTeacherAvailability(id);
      if (!success) {
        return res.status(404).json({ message: "Teacher availability not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting teacher availability" });
    }
  });
  apiRouter.get("/api/teacher-languages", async (req, res) => {
    try {
      const { teacherId } = req.query;
      if (teacherId) {
        const id = parseInt(teacherId);
        if (isNaN(id)) {
          return res.status(400).json({ message: "Invalid teacher ID format" });
        }
        const languages = await storage.getTeacherLanguagesByTeacher(id);
        res.json(languages);
      } else {
        const languages = await storage.getTeacherLanguages();
        res.json(languages);
      }
    } catch (error) {
      res.status(500).json({ message: "Error fetching teacher languages" });
    }
  });
  apiRouter.get("/api/teacher-languages/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const language = await storage.getTeacherLanguage(id);
      if (!language) {
        return res.status(404).json({ message: "Teacher language not found" });
      }
      res.json(language);
    } catch (error) {
      res.status(500).json({ message: "Error fetching teacher language" });
    }
  });
  apiRouter.post("/api/teacher-languages", async (req, res) => {
    try {
      const validatedData = insertTeacherLanguageSchema.parse(req.body);
      const teacher = await storage.getTeacher(validatedData.teacherId);
      if (!teacher) {
        return res.status(404).json({ message: "Teacher not found" });
      }
      const language = await storage.createTeacherLanguage(validatedData);
      res.status(201).json(language);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Invalid language data", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating teacher language" });
    }
  });
  apiRouter.put("/api/teacher-languages/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const existingLanguage = await storage.getTeacherLanguage(id);
      if (!existingLanguage) {
        return res.status(404).json({ message: "Teacher language not found" });
      }
      const validatedData = insertTeacherLanguageSchema.partial().parse(req.body);
      const updatedLanguage = await storage.updateTeacherLanguage(id, validatedData);
      res.json(updatedLanguage);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Invalid language data", errors: error.errors });
      }
      res.status(500).json({ message: "Error updating teacher language" });
    }
  });
  apiRouter.delete("/api/teacher-languages/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteTeacherLanguage(id);
      if (!success) {
        return res.status(404).json({ message: "Teacher language not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting teacher language" });
    }
  });
  apiRouter.get("/api/teacher-course-assignments", async (req, res) => {
    try {
      const { teacherId, courseId } = req.query;
      if (teacherId) {
        const id = parseInt(teacherId);
        if (isNaN(id)) {
          return res.status(400).json({ message: "Invalid teacher ID format" });
        }
        const assignments = await storage.getTeacherCourseAssignmentsByTeacher(id);
        const enrichedAssignments = await Promise.all(assignments.map(async (assignment) => {
          const course = await storage.getCourse(assignment.courseId);
          return {
            ...assignment,
            courseName: course ? course.name : void 0
          };
        }));
        res.json(enrichedAssignments);
      } else if (courseId) {
        const id = parseInt(courseId);
        if (isNaN(id)) {
          return res.status(400).json({ message: "Invalid course ID format" });
        }
        const assignments = await storage.getTeacherCourseAssignmentsByCourse(id);
        res.json(assignments);
      } else {
        const assignments = await storage.getTeacherCourseAssignments();
        res.json(assignments);
      }
    } catch (error) {
      res.status(500).json({ message: "Error fetching teacher course assignments" });
    }
  });
  apiRouter.get("/api/teacher-course-assignments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const assignment = await storage.getTeacherCourseAssignment(id);
      if (!assignment) {
        return res.status(404).json({ message: "Teacher course assignment not found" });
      }
      res.json(assignment);
    } catch (error) {
      res.status(500).json({ message: "Error fetching teacher course assignment" });
    }
  });
  apiRouter.post("/api/teacher-course-assignments", async (req, res) => {
    try {
      const validatedData = insertTeacherCourseAssignmentSchema.parse(req.body);
      const teacher = await storage.getTeacher(validatedData.teacherId);
      if (!teacher) {
        return res.status(404).json({ message: "Teacher not found" });
      }
      const course = await storage.getCourse(validatedData.courseId);
      if (!course) {
        return res.status(404).json({ message: "Course not found" });
      }
      const assignment = await storage.createTeacherCourseAssignment(validatedData);
      res.status(201).json(assignment);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Invalid assignment data", errors: error.errors });
      }
      res.status(500).json({ message: "Error creating teacher course assignment" });
    }
  });
  apiRouter.put("/api/teacher-course-assignments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const existingAssignment = await storage.getTeacherCourseAssignment(id);
      if (!existingAssignment) {
        return res.status(404).json({ message: "Teacher course assignment not found" });
      }
      const validatedData = insertTeacherCourseAssignmentSchema.partial().parse(req.body);
      const updatedAssignment = await storage.updateTeacherCourseAssignment(id, validatedData);
      res.json(updatedAssignment);
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Invalid assignment data", errors: error.errors });
      }
      res.status(500).json({ message: "Error updating teacher course assignment" });
    }
  });
  apiRouter.delete("/api/teacher-course-assignments/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteTeacherCourseAssignment(id);
      if (!success) {
        return res.status(404).json({ message: "Teacher course assignment not found" });
      }
      res.status(204).end();
    } catch (error) {
      res.status(500).json({ message: "Error deleting teacher course assignment" });
    }
  });
  const server = createServer(app2);
  return server;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app = express2();
app.use(express2.json());
app.use(express2.urlencoded({ extended: false }));
app.use((req, res, next) => {
  const start = Date.now();
  const path3 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path3.startsWith("/api")) {
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
async function initApp() {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  if (app.get("env") === "development") {
    const port = process.env.PORT || 5e3;
    server.listen({
      port,
      host: "0.0.0.0",
      reusePort: true
    }, () => {
      log(`serving on port ${port}`);
    });
  } else {
    log(`Server ready for serverless`);
  }
  return app;
}
if (process.env.NODE_ENV === "development") {
  initApp();
}
var index_default = initApp;
export {
  index_default as default
};